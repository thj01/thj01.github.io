<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8" lang="da"/>

	<title>Linux Kommandoer - Thomas Jensen</title>

	<script src="../js/toc2.js" type="text/javascript"></script>
	<script src="https://code.jquery.com/jquery-2.2.2.js"></script>

	<link rel="stylesheet" href="../css/style.css" />
	<link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=Ubuntu+Mono|Ubuntu|Ubuntu+Condensed' rel='stylesheet' type='text/css'>
	

</head>

<!-- 

code converter : http://www.freebits.co.uk/convert-html-code-to-text.html 

-->



<html>

<body onload="generateTOC(document.getElementById('toc'));">

<footer id="license"></footer>

	<script> $( "#license" ).load( "license.html" ); </script>

	<div id="toc">
	
		<p>Indholdsfortegnelse</p>
	
	</div>
	

<div class="title">Kommandoer</div>
	

	
<h1>Linux filosofien</h1>

<p>Linuxfilosofien er if. Mike Gancarz:</p>

<blockquote>An operating system, by its nature, embodies the philosophy of its creators... The creators of the Unix operating system started with a radical concept: they assumed that the user of their operating system would be computer literate from the start. The entire Unix philosophy revolves around the idea that the user knows what he or she is doing.<br/>

<span class="right"><a href="https://en.wikipedia.org/wiki/Unix_philosophy#Mike_Gancarz:_The_UNIX_Philosophy" target="_blank">https://en.wikipedia.org/wiki/Unix_philosophy#Mike_Gancarz:_The_UNIX_Philosophy [110915]</a></span>

</blockquote>

<p>Eller lidt mere sat på spidsen af en anden:</p>

<blockquote>Unix was not designed to stop its users from doing stupid things, as that would also stop them from doing clever things.<br/>

<span class="right"><a href="http://opensource.com/business/14/12/linux-philosophy" target="_blank">http://opensource.com/business/14/12/linux-philosophy [110915]</a></span>

</blockquote>

<p>Det får også betydning for hvordan programmer designes. Grundlæggende er UNIX/Linux programmer bygget op med en simpel og minimalistisk tilgang. Programmer er designet til en ting ... og en ting alene. <span class="inl_cmd">rm</span> er designet til at slette - og det er det som programmet gør. Men ved hjælp af diverse flag, kan de konfigureres til at slette på en smart og intelligent måde.</p>

<blockquote>This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. ...

<br/><br/>

The notion of "intricate and beautiful complexities" is almost an oxymoron. Unix programmers vie with each other for "simple and beautiful" honors — a point that's implicit in these rules, but is well worth making overt.

<span class="right"><a href="https://en.wikipedia.org/wiki/Unix_philosophy#Doug_McIlroy_on_Unix_programming" target="_blank">https://en.wikipedia.org/wiki/Unix_philosophy#Doug_McIlroy_on_Unix_programming [110915]</a></span>

</blockquote>

<p><a href="https://en.wikipedia.org/wiki/Unix_philosophy#Doug_McIlroy_on_Unix_programming" target="_blank">https://en.wikipedia.org/wiki/Unix_philosophy#Doug_McIlroy_on_Unix_programming</a>[110915]</p>

<p>Dette medfører dog også at denne simple og minimalistiske moden ender ud i "Worse is better", simpelthen fordi simpeltheden og minimalismen bliver styrende, fremfor det korrekte, ensarte og helhedsorrienteret ... og dermed bliver det uoverskueligt og komplekst. Dette giver sammen med den åbne udviklingsmodel en evolutionær udvikling, hvor de "stærke" programmer overlever ... og de svage forgår.</p>

<h1>Ubuntu</h1>

<p>Ubuntu findes i to versioner: LTS (<span class="bold">L</span>ong <span class="bold">T</span>erm <span class="bold">S</span>upport ) og ikke-LTS. LTS udgivelserne frigives hvert andet år, og er kendetegnet ved at der garanteres 5 års sikkerhedsopdateringer. For ikke-LTS udgaverne gælder det at de bliver sikkerhedsopdateret 9 måneder frem.</p> 

<p>Forskellen mellem dem ligger i måden man udvælger softwaren og måden udviklingen og testen bliver lavet.  If. Canonical gælder det for LTS udgaverne at de er:</p>

<ul class="disc">
	<li>Virksomheds fokuseret</li>
	<li>Kompatible med ny hardware.</li>
	<li>Mere testet</li>
	<li>Konservativt i sit software valg</li>
</ul>

<p>Kilde: <a href="https://wiki.ubuntu.com/LTS" target="_blank">https://wiki.ubuntu.com/LTS</a></p>

<p>LTS versionerne er altså ikke "cutting edge", men man er mere fokuseret på at stabilisere eksisterende funktioner end at introducere nye. Dette betyder ikke at ikke-LTS'erne er usikre eller mangler test - blot at disse er rettet mere mod udvikling, og at erfaringerne herfra kommer til at være hjørnestenen i den næste LTS version. I nedestående skema kan du se forskellen mellem dem og den ligger primært i at LTS udgaven får låst sine features 4 uger før ikke-LTS udgaven, som så anvendes til test.</p>

<p>Versionsnummeret (de to første numre) angiver først udgivelsesåret året, derefter måneden og så udgaven. 14.04.2 LTS er altså den anden version af Ubuntu der er udgivet april månede 2014. Er der et ekstra tal på beskriver det versionsnummeret (point release). Man bør altid installere den nyeste version da den indeholder flere features og understøttelse for nyere hardware. Man kan løbende opgradere kernen hvis det bliver nødvendigt.</p>

<table class="">
	<thead>
		<tr>
			<th>Uge</th>
			<th>14.04 LTS</th>
			<th>14.10</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1</td>
			<td>Toolchain uploaded</td>
			<td>Toolchain uploaded</td>
		</tr>
		<tr>
			<td>2</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>3</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>4</td>
			<td></td>
			<td></td>
		</tr>		
		<tr>
			<td>5</td>
			<td>FeatureDefinitionFreeze</td>
			<td></td>
		</tr>
		<tr>
			<td>6</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>7</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>8</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>9</td>
			<td>Alpha 1 (for opt-in flavors)</td>
			<td>FeatureDefinitionFreeze</td>
		</tr>
		<tr>
			<td>10</td>
			<td></td>
			<td>Alpha 1 (for opt-in flavors)</td>
		</tr>
		<tr>
			<td>11</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>12</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>13</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>14</td>
			<td>Alpha 2 (for opt-in flavors)</td>
			<td></td>
		</tr>
		<tr>
			<td>15</td>
			<td></td>
			<td>Alpha 2 (for opt-in flavors)</td>
		</tr>
		<tr>
			<td>16</td>
			<td>Debian Import Freeze</td>
			<td>Debian Import Freeze</td>
		</tr>
		<tr>
			<td>17</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>18</td>
			<td>FeatureFreeze</td>
			<td>FeatureFreeze</td>
		</tr>
		<tr>
			<td>19</td>
			<td>Beta 1 Freeze</td>
			<td>Beta 1 Freeze</td>
		</tr>
		<tr>
			<td>20</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>21</td>
			<td>UserInterfaceFreeze</td>
			<td>UserInterfaceFreeze</td>
		</tr>
		<tr>
			<td>22</td>
			<td>DocumentationStringFreeze</td>
			<td>DocumentationStringFreeze</td>
		</tr>
		<tr>
			<td>23</td>
			<td>Final Beta Freeze -> Final Beta</td>
			<td>Final Beta Freeze -> Final Beta</td>
		</tr>
		<tr>
			<td>24</td>
			<td>KernelFreeze</td>
			<td>KernelFreeze</td>
		</tr>
		<tr>
			<td>25</td>
			<td>FinalFreeze, ReleaseCandidate</td>
			<td>FinalFreeze, ReleaseCandidate</td>
		</tr>
		<tr>
			<td>26</td>
			<td>FinalRelease, Ubuntu Ubuntu 14.04 LTS</td>
			<td>FinalRelease, Ubuntu Ubuntu 14.10</td>
		</tr>
		<tr>
			<td>1</td>
			<td>Toolchan Uploaded 14.10</td>
			<td>Toolchan Uploaded 15.04</td>
		</tr>
		
	</tbody>
</table>


<p>Hvis du vil vide mere om selve testprocedurerne kan du herunder finde henvisninger til </p>

<p>Kilde: <a href="https://wiki.ubuntu.com/TrustyTahr/ReleaseSchedule" target="_blank">https://wiki.ubuntu.com/TrustyTahr/ReleaseSchedule (14.04)</a> </br>Kilde: <a href="https://wiki.ubuntu.com/UtopicUnicorn/ReleaseSchedule" target="_blank">https://wiki.ubuntu.com/UtopicUnicorn/ReleaseSchedule (14.10)</a></p>



<h1>Terminalen - Linux' kraftværk</h1>

<h2>Kapitles opbygning</h2>

<p>Dette kapitel giver en grundlæggende gennemgang af filsystemet, superbrugeren og terminalen (kommandolinien) og kommandostrukturen i Linux.</p>

<h2>Anvendt installation</h2>

<p>For at eksemplificere guiden, er der blevet oprettet en virtuel installation med VirtualBox med følgende Indstillinger:</p>

<table class="">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>RAM</td>
			<td>4096 MB</td>
		</tr>
		<tr>
			<td>Grafik hukommelse</td>
			<td>128 MB og 3D-acceleration </td>
		</tr>
		<tr>
			<td>Harddiske</td>
			<td>2 x 100GB (SATA)</td>
		</tr>
		<tr>
			<td>Netværk</td>
			<td>NAT</td>
		</tr>
	</tbody>
</table>

<p>Harddiskpartitionering</p>

<table class="">
	<thead>
		<tr>
			<th>Harddisk</th>
			<th>Drev</th>
			<th>Betegnelse</th>
			<th>Størrelse</th>
			<th>Anvendelse</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td rowspan="4">Harddisk 1 (100 GB)</td>
			<td>/dev/sda1</td>
			<td>/</td>
			<td>50000Mb (50 Gb)</td>
			<td>System</td>
		</tr>
		<tr>
			<td>/dev/sda2</td>
			<td>Ingen</td>
			<td>4096MB (4 GB)</td>
			<td>Swap</td>
		</tr>
		<tr>
			<td>/dev/sda3</td>
			<td>/data</td>
			<td>31000MB (31 GB)</td>
			<td>Data</td>
		</tr>
		<tr>
			<td>Ledig plads</td>
			<td> - </td>
			<td>20,9 GB</td>
			<td>Linux?</td>
		</tr>
		<tr>
			<td>Harddisk 2 (100GB)</td>
			<td colspan="4">Ikke konfigureret under installation</td>
		</tr>
	</tbody>
</table>

<p>Harddisk 2 vil blive konfigureret i afsnittet XXXXXXXXXXXXXXXXX</p>



<h2>Hvad er en terminal</h2>

<p>Terminalen er en tekstbaseret tilgang til Linux. Normalt ser vi en GUI som styresystemet, men det er reelt blot en skal hvor vi kan arbejde med programmer grafisk. Der er vi vant til at pege og vælge programmer og funktioner ved at klikke os frem. I terminalen skal vi "snakke" med maskinen og fortælle den hvad en skal gøre, hvordan den skal gøre det og hvad den skal gøre med med.</p>

<p>Det som er udfordringen i starten er, at man skal lære et nyt sprog, og det kræver noget tilvending når man er vant til at pege og klikke sig frem. Det er næsten som forskellen på at læse en bogen eller se filmen. De kan begge noget specielt, men bogen har nuancer som en film ikke kan skabe - nemlig vores måde at se tingene på.</p>

<h2>Tilgå terminalen</h2>

<p>Når Ubuntu er startet op kører der 7 terminalsessions, som man kan logge ind på. Som standard starer man op i den 7 terminal som kører Ubuntu GUI. Disser terminaler kan tilgåes ved hjælp af tastekombinationen <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd> → <kbd>F7</kbd>, hvor F'taller angiver den konkrete terminal.Så længe du befinder dig i VirtualBox skal du anvende dennes interne tastekombination angivet i nedestående skema skema.</p>

<table id="">
	<thead>
		<tr>
			<th>Rigtige genvej</th>
			<th>VirtualBox' genvej</th>
			<th>Resultat</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
				<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd> <br/><br/>til <br/><br/><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F6</kbd>
			</td>
			<td>
				<kbd>højreCtrl</kbd>+<kbd>F1</kbd><br/><br/>til <br/><br/><kbd>højreCtrl</kbd>+<kbd>F6</kbd>
			</td>
			<td>Åbner de bagvedkørende sessions</td>
		</tr>
		<tr>
			<td><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F7</kbd></td>
			<td><kbd>højreCtrl</kbd>+<kbd>F7</kbd></td>
			<td>Åbner den grafiske brugerflade</td>
		</tr>
	</tbody>
</table>

<p>Hvis man har startet Ubuntu op kan man tilgå en terminalsession ved hjælp af tastekombinationen <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>T</kbd>. Det vil starte en termial op i et nyt vindue, og hvor din bruger er logget ind.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ 






</pre>

<p>jo længere tid man bruger Linux - jo mere vil man anvende terminalen. Simpelthen fordi det er smartere og langt mere effektivt end at klikke sig frem. </p>

<h2>Generelt om terminalen</h2>

<p>Når man er logget ind får aman følgende information fra kommandolinien</p>

<ol class="">
	<li>Hvem man er,</li>
	<li>hvilken computer man sidder ved,</li>
	<li>hvor man står i filsystemet og </li>
	<li>Hvilken type bruger man er</li>
</ol>

<code class="cmd">tj@tj-VirtualBox:~$ </code>

<table class="">
	<thead>
		<tr>
			<th></th>
			<th></th>
			<th></th>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>tj</td>
			<td>@</td>
			<td>tj-Virtualbox</td>
			<td>~</td>
			<td>$</td>
		</tr>
		<tr>
			<td>brugernavn</td>
			<td>på</td>
			<td>PC-navn</td>
			<td>Brugerens hjem</td>
			<td>Almindelig bruger</td>
		</tr>
	</tbody>
</table>

<p>$ bliver erstattet af # hvis man er superbruger (root):</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo su
[sudo] password for tj: 
root@tj-VirtualBox:/home/tj# 



</pre>

<p>De fleste kommandoer har tre sektioner:</p>

<code class="cmd">[kommando] [optioner] [målet for kommandoen]</code>

<p>Eksempel</p>

<code class="cmd">ping -c 4 www.dr.dk</code>

<table class="commands">
	<thead>
		<tr>
			<th>Kommando</th>
			<th>Option</th>
			<th>Mål</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>ping</td>
			<td>-c 4</td>
			<td>www.dr.dk</td>
		</tr>
		<tr>
			<td>programmet</td>
			<td>Optionen (i dette tilfælde 4 gange)</td>
			<td>Målet kommandoen skal arbejde med</td>
		</tr>
	</tbody>
</table>


<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ping -c 4 dr.dk
PING dr.dk (159.20.6.38) 56(84) bytes of data.
64 bytes from 159.20.6.38: icmp_seq=1 ttl=63 time=13.0 ms
64 bytes from 159.20.6.38: icmp_seq=2 ttl=63 time=12.9 ms
64 bytes from 159.20.6.38: icmp_seq=3 ttl=63 time=13.3 ms
64 bytes from 159.20.6.38: icmp_seq=4 ttl=63 time=14.0 ms

--- dr.dk ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3004ms
rtt min/avg/max/mdev = 12.966/13.342/14.017/0.423 ms
</pre>

<p>Hvis optionen -c 4 ikke tilføjes, kører kommandoen indtil den bliver afbrudt med tastekombinationen <kbd>Ctrl</kbd>+<kbd>c</kbd>  (stop kommandoen) eller <kbd>Ctrl</kbd>+<kbd>z</kbd> (afbryd programmet).</p>

<p>Nogle kommandoer kan indlejrer – f.eks. time (finder tidsforbruget af en kommando)</p>

<code class="cmd">time ping -c 4 www.dr.dk</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ time ping -c 4 dr.dk
PING dr.dk (159.20.6.38) 56(84) bytes of data.
64 bytes from 159.20.6.38: icmp_seq=1 ttl=63 time=12.6 ms
64 bytes from 159.20.6.38: icmp_seq=2 ttl=63 time=13.9 ms
64 bytes from 159.20.6.38: icmp_seq=3 ttl=63 time=12.3 ms
64 bytes from 159.20.6.38: icmp_seq=4 ttl=63 time=14.6 ms

--- dr.dk ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3005ms
rtt min/avg/max/mdev = 12.331/13.369/14.614/0.929 ms

real	0m3.041s
user	0m0.004s
sys	0m0.000s
</pre>

<h2>Superbrugeren</h2>

<p>Alle Linux har en superbruger (<span class="inl_cmd">root</span>), som har rettigheder til at gøre alt på maskinen. Denne bruger anvender man til at lave systemarbejde med f.eks. at konfigurere programmer og installere programmer. På Ubuntu er <span class="inl_cmd">root</span>-kontoen ikke aktiveret, men man kan "opgradere" sin bruger til at have administratorrettigheder ved hjælp af kommandoen <span class="inl_cmd">sudo</span> (<span class="bold">su</span>peruser <span class="bold">do</span>). <span class="inl_cmd">sudo</span> kommandoen undersøger om man er medlem af sudo-gruppen og giver igennem denne gruppe adgang til at man kan udføre administrationsarbejde.</p>

<p>I eksemplet herunder vil jeg se informationer om den første harddisk (<span class="inl_cmd">/dev/sda</span>) ved hjælp af fdisk kommandoen <span class="inl_cmd">fdisk -d /dev/sda</span>:</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ fdisk -l /dev/sda
Kan ikke åbne /dev/sda
tj@tj-VirtualBox:~$ sudo fdisk -l /dev/sda
[sudo] password for tj: 

Disk /dev/sda: 107.4 GB, 107374182400 bytes
255 hoveder, 63 sektorer/spor, 13054 cylindre, i alt 209715200 sektorer
Enheder = sektorer af 1 * 512 = 512 byte
Sektorstørrelse (logisk/fysisk): 512 byte / 512 byte
I/O-størrelse (minimum/optimal): 512 byte / 512 byte
Diskidentifikation: 0x00031198

    Enhed Opstart   Start         Slut     Blokke   Id  System
/dev/sda1   *        2048    97656831    48827392   83  Linux
/dev/sda2        97656832   105656319     3999744   82  Linux swap / Solaris
/dev/sda3       105656320   166203391    30273536   83  Linux
</pre>

<p>Under første kørsel bliver det gjort med brugeren tj's rettigheder. Det medfører at <span class="inl_cmd">fdisk</span> ikke har ret til at kigge på harddiskens data. I det andet tilfælde "løfter" jeg rettighedsniveauet til <span class="inl_cmd">root</span>-niveau, som så giver mig de informationer jeg ønsker.</p>

<p>Hvis der skal udføres meget administrationsarbejde vælger man ofte at bruge kommandoen <span class="inl_cmd">sudo su</span>. Denne kommando ændrer ens bruger til <span class="inl_cmd">root</span>:</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo su
[sudo] password for tj: 
root@tj-VirtualBox:/home/tj# 
</pre>

<p>Denne kommando gør at filen /etc/network/interfaces bliver kørt i tekstredigeringsprogrammet nano med superbrugerrettigheder.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>sudo</td>
			<td>Udfør kommandoen som superbruger</td>
		</tr>
		<tr>
			<td>sudo su</td>
			<td>Ændrer en til root bruger, så man ikke behøver at skrive sudo</td>
		</tr>
		<tr>
			<td>gksudo</td>
			<td>Starter GUI programmer op med superbrugerrettigheder</td>
		</tr>
	</tbody>
</table>

<p>Hvis man kører flere kommandoer med <span class="inl_cmd">sudo</span> lige efter hinanden, behøver man ikke genindtaste sit password, da rettigehden bliver husket i en længere tid. Derfor bør man altid afslutte den session man har gang i med kommandoen <span class="inl_cmd">exit</span>. Det gælder især hvis man har anvendt <span class="inl_cmd">sudo su</span>, da det logger en af <span class="inl_cmd">root</span>-kontoen.</p>

<pre class="ubuntu_terminal">
root@tj-VirtualBox:/home/tj# exit
exit
tj@tj-VirtualBox:~$ 
</pre>

<p>Skriver man exit i et terminalvindue vil det lukke den kørende session ned. Det betyder at hvis man lige har startet den op, med <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>t</kbd>, vil vinduet lukke ned igen.</p>

<h2>man pages</h2>

<p>Til alle terminalens kommandoer er der skrevet en manual, og den kan man tilgå ved med kommandoen <span class="inl_cmd">man [kommando]</span> . Her kan man læse hvordan 
kommandoen bruges (Synopsis) og de optioner man kan tilføje (Descriptions). Herunder er de første linier af kommandoen <span class="inl_cmd">man ls</span></p>

<pre class="ubuntu_terminal">
LS(1)                            User Commands                          LS(1)

<span class="bold">NAME</span>
       ls - list directory contents

<span class="bold">SYNOPSIS</span>
       <span class="bold">ls</span> [<span class="underline">OPTION</span>]... [<span class="underline">FILE</span>]...

<span class="bold">DESCRIPTION</span>
     List  information  about  the FILEs (the current directory by default).
     Sort entries alphabetically if none of -cftuvSUX nor --sort  is  speci‐
     fied.

     Mandatory  arguments  to  long  options are mandatory for short options
     too.

       <span class="bold">-a, --all</span>
              do not ignore entries starting with .

       <span class="bold">-A, --almost-all</span>
              do not list implied . and ..
</pre>

<p>Man scroller med piletasterne og afslutter med [q].</p>

<p>De kan også findes på Internettet. F.eks. kan man finde ls' online udgave ved at søge med ordene: <span class="inl_cmd">ubuntu man ls</span>.  Herefter vælger man sin version af Ubuntu, og får den 
relevante mannualside.</p>

<figure id="">

	<img class="p90"src="images/kommandoer_man_pages_01.png" alt="" title="" />

	<figcaption>man pages på Ubuntu.com</figcaption>

</figure>

<h1>Filsystemet</h1>

<p>Herunder får du præsenteret en række kommandoer, som giver dig mulighed for at administrere systemet, manipulere med filer, få informationer om hardware og netværk.</p>

<p>Til forskel fra Windows der bliver konfigureret ved hjælp af registreringsdatabases styres Linux af ”flade” filer, forstået på den måde at programmer bliver konfigureret ved hjælp af en eller flere tekstbaserede konfigurationsfiler. Har man lavet ændringer i en konfigurationsfil genstarter man tjenesten, som herefter indlæser og anvender den nye konfigurationsfil. Mange af kommandoerne er vist med eksempler, der er er praktisk anvendelige. </p>

<p>En af de ting der også er nyt for mange der bruger Linux er de rettigheder filerne har. Alle filer og mapper får sat læse/skrive/køre rettigheder for henholdsvis ejeren, gruppen og alle andre. <span class="inl_cmd">root</span>-brugeren (bliver også kaldt supueruser)  er dog undtaget for denne regel. <span class="inl_cmd">root</span> kan alt på en Linux computer, så derfor skal kommandoer der har med selve operativsystemet og konfigurationsfiler køres med rootbrugerens rettigheder. Man skifter til roorbrugerens rettigheder ved at køre kommandoen <span class="inl_cmd">sudo</span>. Skal man køre mange kommandoer kan man køre kommandoen <span class="inl_cmd">sudo su</span>, og ændres brugeren til <span class="inl_cmd">root</span>. I disse dokumenter har jeg valgt at vise kommandoerne uden sudo foran.</p>

<h2>Alt er filer</h2>

<p>I Linux er alt filer. En mappe er egentlig bare en fil, der henviser til en samling af filer, og hardware er præsenteret ved hjælp af en fil. F.eks. har den første partition på den første SATA disk i systemet filadressen <span class="inl_cmd">/dev/sda1</span> og det første netkort <span class="inl_cmd">/dev/eth0</span>. Så hvis man ønsker at skrive noget til det første netkort (f.eks. data eller konfiguration) skal det altså sendes til filen <span class="inl_cmd">/dev/eth0</span>.</p>

<h2>Filsystemets opbygning</h2>

<p>I Linuxsystemer er alt filer og filsystemet tager udgangspunkt i roden (/) hvorfå alle mapper er monteret. Mapperne i roden af filsystemet følger <a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" target="_blank">FHS</a> (<span class="bold">F</span>ilesystem <span class="bold">H</span>ierarchy <span class="bold">S</span>tandarden) som bliver vedligeholdt af <a href="https://en.wikipedia.org/wiki/Linux_Foundation" target="_blank">Linux Foundattion</a>. Herunder er de mapper der ligger i roden i Ubuntu, med en kort forklaring om hvad de indeholder. De mapper der er markeret med fed er dem som man ofte vil støde i systemarbejde på Ubuntu.
</p>

<p>En anden stor fordel ved at anvende denne standard er, at man ikke skal bekymre sig om hvor f.eks. konfigurationsfilerne ligger. De vil altid ligge i <span class="inl_cmd">/etc</span>.</p>

<p>Herunder er et overblik over mapperne på roden og hvad de indeholder. Mapperne der er markeret med fed, er dem man oftest skal anvende når man laver systemarbejde.</p>

<table class="cmd_table">
	<tbody>
		<tr>
			<td>/</td>
			<td>Roden – det nederste niveau</td>
		</tr>
		<tr>
			<td>/bin</td>
			<td>Binære filer - Her ligger mange af systemkommandoerne f,eks. ls og cd</td>
		</tr>
		<tr>
			<td>/boot</td>
			<td>Opstartsfiler f.eks. Linux kernen</td>
		</tr>
		<tr>
			<td>/dev</td>
			<td>Devices - f.eks. harddiske (sda1) og netkort (eth0)</td>
		</tr>
		<tr>
			<td><span class="bold">/etc</span></td>
			<td><span class="bold">Konfigurationsfiler til systemet.</span></td>
		</tr>
		<tr>
			<td><span class="bold">/home</span></td>
			<td><span class="bold">Brugernes hjemmemapper</span></td>
		</tr>
		<tr>
			<td>/lib</td>
			<td>32bits programbiblioteker (libraries) der bliver delt af computerens programmer</td>
		</tr>
		<tr>
			<td>/lib64</td>
			<td>64 bits programbiblioteker</td>
		</tr>
		<tr>
			<td>/lost+found</td>
			<td>Fundne datafragmenter der ikke hører til nogle steder</td>
		</tr>
		<tr>
			<td>/media</td>
			<td>Mappen hvor transportable enheder monteres. F.eks. USB-og CD/DVD-drev.</td>
		</tr>
		<tr>
			<td>/mnt</td>
			<td>En mappe hvor man montere midlertidige drev. F.eks. netværksdrev </td>
		</tr>
		<tr>
			<td>/opt</td>
			<td>Installerede programmer der ikke administreres af apt</td>
		</tr>
		<tr>
			<td>/proc</td>
			<td>Processer - det er et real-time filsystem, der er placeret i RAM.</td>
		</tr>
		<tr>
			<td>/root</td>
			<td>Superbrugerens hjemmemappe</td>
		</tr>
		<tr>
			<td>/run</td>
			<td>En mappe der er placeret i RAM - her lægges tmp filer</td>
		</tr>
		<tr>
			<td>/sbin</td>
			<td>root's binære filer -</td>
		</tr>
		<tr>
			<td><span class="bold">/srv</span></td>
			<td><span class="bold">Servermappen. Heri lægges alle filer der deles med andre</span></td>
		</tr>
		<tr>
			<td>/sys</td>
			<td>En mappe placeret i RAM, der viser informationer om hardware</td>
		</tr>		
		<tr>
			<td>/tmp</td>
			<td>En mappe til midlertidige filer</td>
		</tr>
		<tr>
			<td>/usr</td>
			<td>Brugernes værktøjs- og programmappe. Indeholder indstillinger til de installerede programmer</td>
		</tr>
		<tr>
			<td><span class="bold">/var</span></td>
			<td><span class="bold">Variable filer - filer der ændrer sig ofte f.eks. logfiler. Det er også i denne mappe at man finder Apaches www mappe.</span></td>
		</tr>		
	</tbody>
</table>


<h2>Filnavne</h2>

<p>Linux anvender modsat windows både de store og små bogstaver i alfabetet. Derfor vil der under Linux være forskel på filerne <span class="inl_cmd">data</span> og <span class="inl_cmd">Data</span> og brugerne <span class="inl_cmd">tj</span> og <span class="inl_cmd">Tj</span>.</p>
	
<p>Man kan heller ikke se på en fils "efternavn" om det er et program. I windows kan programmer genkendes ved deres efternavn f.eks. <span class="inl_cmd">.exe</span> eller <span class="inl_cmd">.msi</span>. I Linux gøres en fil eksekverbar, ved at man ændre i den rettigheder. Derfor kan man ikke umiddelbart se om en fil kan køres eller ej. Det er også normen at man uploader og sender programmer uden at have sat eksekverrettigheder. På den måde sikrer man sig at man ikke ved et uheld kommer til at køre en fil.</p>

<p>Men efternavne på filer anvendes også i Linux, men det er mere for at programmer kan genkende filerne. Det gælder f.eks: <span class="inl_cmd">*.pdf</span>, <span class="inl_cmd">*.odt</span>, <span class="inl_cmd">*.jpg</span> og <span class="inl_cmd">*.png</span>. 
	
I styresystemet Linux anvendes der ikke ”efternavne” til filer som f.eks. exe, dll og inf, for at afgøre hvilken type filen er. Det styres med rettigheder. Derfor kan man ikke umiddelbart se på en fil om det er et program eller blot en tekstfil. Der anvendes dog filefternavne til filer med specifikke formater, f.eks. til tekst- og billedbehandlingsprogrammer f.eks. *.pdf, *.odt, *.jpg, *.png osv. For at kunne genkende script filer giver man dem efternavnet <span class="inl_cmd">*.sh</span>. Filrettigheder skal dog sættes rigtigt før en <span class="inl_cmd">*.sh</span> fil kan køres.</p>

<h1>Navigation i filsystemet</h1>

<p>For at navigere rundt i og orientere sig i filsystemet anvender man følgende kommandoer:</p>

<ul class="disc">
	<li><span class="inl_cmd">cd</span> - change directory</li>
	<li><span class="inl_cmd">ls</span> - list</li>
	<li><span class="inl_cmd">pwd</span> - print working directory</li>
	<li><span class="inl_cmd">tree</span> – viser filerne i træstruktur </li>
</ul>

<p>Herunder angives eksempler med kommandoerne:</p>

<h2><span class="inl_cmd">cd</span> – change directory</h2>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
		<tbody>
		<tr>
			<td>cd /etc/apt</td>
			<td>Skift til mappen <span class="inl_cmd">/etc/apt</span></td>
		</tr>
		<tr>
			<td>cd /</td>
			<td>Skift til roden af filstrukturen</td>
		</tr>
		<tr>
			<td>cd ..</td>
			<td>Gå et mappeniveau ned</td>
		</tr>
		<tr>
			<td>cd ~</td>
			<td>Skift til din hjemmemappe</td>
		</tr>
	</tbody>
</table>

<h2><span class="inl_cmd">ls</span> - list</h2>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>ls</td>
			<td>Viser filer og mapper</td>
		</tr>
		<tr>
			<td>ls -al</td>
			<td>Udvidet visning med de skjulte filer/mapper</td>
		</tr>
		<tr>
			<td>ls -al /etc/log</td>
			<td>Udvidet visning af <span class="inl_cmd">/etc/log</span></td>
		</tr>
		<tr>
			<td>ls -d</td>
			<td>Vis kun filer</td>
		</tr>
		<tr>
			<td>ls -d .*</td>
			<td>Vis kun skjulte filer</td>
		</tr>
		<tr>
			<td>ls -d */</td>
			<td>Viser kun mapper</td>
		</tr>
	</tbody>
</table>

<h2><span class="inl_cmd">pwd</span> – print working director</h2>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>pwd</td>
			<td>Viser hvor man er i filsystemet</td>
		</tr>
	</tbody>
</table>

<h2><span class="inl_cmd">tree</span></h2>

<p><span class="inl_cmd">tree</span> viser indholdet af en mappe i en træstruktur. Det følger ikke med som standard og skal derfor installeres først</p>

<code class="cmd">sudo apt-get install tree -y</code>

<p>Det kan f.eks. bruges til vise filstrukturen som herunder <span class="inl_cmd">tree /usr -d -L 1</span></p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~# tree /usr -d -L 1	
<span class="blue1">/usr</span>
├── <span class="blue1">bin</span>
├── <span class="blue1">games</span>
├── <span class="blue1">include</span>
├── <span class="blue1">lib</span>
├── <span class="blue1">local</span>
├── <span class="blue1">sbin</span>
├── <span class="blue1">share</span>
└── <span class="blue1">src</span>

9 directories
</pre>

<p>Kommandoen udvider ls ved at man kan vise det i flere niveauer. Prøv f.eks. at køre kommandoen:</p>

<code class="cmd">tree /usr -d -L 2</code>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>tree</td>
			<td>Viser filerne i træ struktur i den lokale mappe</td>
		</tr>
		<tr>
			<td>Tree /usr</td>
			<td>Viser træstrukturen i mappen <span class="inl_cmd">/usr</span></td>
		</tr>
		<tr>
			<td>Tree /usr -d</td>
			<td>Viser kun mapper i <span class="inl_cmd">/usr</span></td>
		</tr>
		<tr>
			<td>Tree /usr -d -L 1</td>
			<td>Viser mapperne i <span class="inl_cmd">/usr</span> i et niveauer</td>
		</tr>
		<tr>
			<td>tree /usr -du -L 1</td>
			<td>Viser mapperne i <span class="inl_cmd">/usr</span> i et niveauer med ejerskab</td>
		</tr>
		<tr>
			<td>tree /usr --du -L 1</td>
			<td>Viser mapperne i <span class="inl_cmd">/usr</span> i et niveauer med filstørrelser</td>
		</tr>
		<tr>
			<td>tree /usr --dirsfirst -L 1</td>
			<td>Viser alle filerne i <span class="inl_cmd">/usr</span>, men sætter mapperne først.</td>
		</tr>
	</tbody>
</table>

<h1>Størrelse af filer</h1>

<h2><span class="inl_cmd">du</span> - Disk usage</h2>

<p>For at se hvor meget filerne i en folder fylder anvendes <span class="inl_cmd">du</span>.</p>

<code class="cmd">du -hs ~</code>

<p>Herunder kan du se output fra mit eget system. Læg mærke til at der er nogle mapper selv brugerne ikke har adgang til.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ du -hs ~
2,6M	/home/tj
</pre>

<h2><span class="inl_cmd">df</span></h2>

<p>For at se den brugte plads anvendes kommandoen <span class="inl_cmd">df</span></p>

<code class="cmd">df -h *partition*</code>

<p><span class="inl_cmd">-h</span> gør at, størrelsen vises i MB og GB i stedet for Kb.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>df -h</td>
			<td>Viser brugt plads på alle mountede partitioner i GB</td>
		</tr>
		<tr>
			<td>df -h /</td>
			<td>Viser brugt plads på <span class="inl_cmd">/</span></td>
		</tr>
		<tr>
			<td>df -hT /</td>
			<td>Viser også hvilket filsystem der anvendes</td>
		</tr>
	</tbody>
</table>

<p>Læg mærke til at <span class="inl_cmd">df</span> viser pladsforbrug på den valgte partition, hvis du vælger en mappe derpå.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ df -h ~
Filsystem                                              Størr Brugt  Tilb Brug% Monteret på
/dev/disk/by-uuid/c2c76ea3-8bee-4930-be2c-20d11a7358c1   46G  4,4G   40G   10% /
</pre>

<h1><span class="inl_cmd">lsblk</span> - List block devices</h1>

<p><span class="inl_cmd">lsblk</span> er den bedste måde at skabe sig et overblik over harddiske og partitioner på computeren. Herunder er et eksempel:</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0   100G  0 disk 
├─sda1   8:1    0  46,6G  0 part /
├─sda2   8:2    0   3,8G  0 part [SWAP]
└─sda3   8:3    0  28,9G  0 part /data
sdb      8:16   0   100G  0 disk 
sr0     11:0    1  1024M  0 rom  
</pre>

<p>Læg mærke til at der ikke er noget mountpoint til <span class="inl_cmd">sdb</span> og <span class="inl_cmd">sr0</span>. Det skyldes at computeren har registreret den ikke konfigurerede harddisk (<span class="inl_cmd">sdb</span>) der ikke er konfigureret endnu, samt det tomme DVD-drev (<span class="inl_cmd">sr0</span>).</p>

<p>lsblk kan konfigueres til at vise mange data om ens partitioner f.eks:</p>

<code class="cmd">sudo lsblk -o name,rm,ro,size,type,fstype,uuid</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo lsblk -o name,rm,ro,size,type,fstype,mountpoint,uuid
NAME   RM RO   SIZE TYPE FSTYPE MOUNTPOINT UUID
sda     0  0   100G disk                   
├─sda1  0  0  46,6G part ext4   /          c2c76ea3-8bee-4930-be2c-20d11a7358c1
├─sda2  0  0   3,8G part swap   [SWAP]     1c538622-36c6-4fcb-a127-636a82ad84e3
└─sda3  0  0  28,9G part ext4   /data      a2d7f466-6131-4048-86b1-b0304e9bd905
sdb     0  0   100G disk                   
sr0     1  0  1024M rom  
</pre>

<table class="">
	<thead>
		<tr>
			<th>option</th>
			<th>Forklaring</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>name</td>
			<td>navn - hvad hedder enheden</td>
		</tr>
		<tr>
			<td>rm</td>
			<td>Removable - er enheden flytbar. 0 = nej, 1 = ja</td>
		</tr>
		<tr>
			<td>ro</td>
			<td>readl-only - Er enheden skrivebeskyttet. 0 = nej, 1 = ja</td>
		</tr>
		<tr>
			<td>size</td>
			<td>Størrelse i GB</td>
		</tr>
		<tr>
			<td>fstype</td>
			<td>Partitionens filsystem</td>
		</tr>
		<tr>
			<td>mountpount</td>
			<td>Partitionens monteringspunkt</td>
		</tr>
		<tr>
			<td>uuid</td>
			<td>partitionens UUID (<span class="bold">U</span>niversally <span class="bold">U</span>nique <span class="bold">ID</span>entifier)</td>
		</tr>
	</tbody>
</table>

<h1>Arbejde med filer</h1>

<p>For at kunne navigere rundt i filsystemet anvender man primært følgende kommandoer:</p>

<ul class="disc">
	<li><span class="inl_cmd">more</span> - vis indholdet af filer</li>
	<li><span class="inl_cmd">tail / head</span> - vis slutningen / starten af filer</li>
	<li><span class="inl_cmd">cat</span> - catenade</li>
	<li><span class="inl_cmd">grep</span> - Pibes og filtre </li>
	<li><span class="inl_cmd">echo</span> – indsæt tekst i filer </li>

</ul>

<h2><span class="inl_cmd">more</span> - vis indholdet af filer</h2>

<p>Ved hjælp af more kan man få indholdet af en fil skrevet ud på skærmen. Når skærmen er fyldt kan man se hvor stor en procentdel af filen man har fået vist. Man går en linie frem ad gangen ved at trykke på <kbd>Enter</kbd> og en side længere ned med <kbd>Mellemrum</kbd>.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>more /etc/passwd</td>
			<td>Vis indhold af filen <span class="inl_cmd">/etc/passwd</span></td>
		</tr>
	</tbody>
</table>

<p>man-page <span class="inl_cmd">more</span>: 
	<a href="http://manpages.ubuntu.com/manpages/trusty/man1/more.1.html" target="_blank">
	http://manpages.ubuntu.com/manpages/trusty/man1/more.1.html</a></p>

<h2><span class="inl_cmd">Tail / head</span> – vis de sidste/ første linier af filer</h2>

<p>Kommandoen er god til at se om noget er blevet korrekt tilføjet til en fil.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>tail /etc/passwd</td>
			<td>Vis de sidste 10 linier af <span class="inl_cmd">/etc/passwd</span></td>
		</tr>
		<tr>
			<td>tail -5 /etc/passwd</td>
			<td>Vis de sidste 5 linier af <span class="inl_cmd">/etc/passwd</span></td>
		</tr>
		<tr>
			<td>head -5 /etc/passwd</td>
			<td>Vis de første 5linier af <span class="inl_cmd">/etc/passwd</span></td>
		</tr>
	</tbody>
</table>

<p>man-page <span class="inl_cmd">tail</span>: 
	<a href="http://manpages.ubuntu.com/manpages/trusty/en/man1/tail.1.html" target="_blank">
	http://manpages.ubuntu.com/manpages/trusty/en/man1/tail.1.html</a></p>

<p>man-page <span class="inl_cmd">head</span>: 
	<a href="http://manpages.ubuntu.com/manpages/trusty/man1/head.1.html" target="_blank">
	http://manpages.ubuntu.com/manpages/trusty/man1/head.1.html</a></p>
	

<h2><span class="inl_cmd">grep</span> - filtrere filer</h2>

<p><span class="inl_cmd">grep</span> -  anvendes til at finde tekststrenge i en fil.</p>

<code class="cmd">grep backup /etc/passwd</code>

<pre class="ubuntu_terminal">
thoj@thoj-VirtualBox:~$ grep backup /etc/passwd
<span class="red">backup</span>:x:34:34:<span class="red">backup</span>:/var/<span class="red">backups</span>:/usr/sbin/nologin
</pre>

<p>man-page <span class="inl_cmd">grep</span>: 
	<a href="http://manpages.ubuntu.com/manpages/trusty/man1/grep.1.html" target="_blank">
	http://manpages.ubuntu.com/manpages/trusty/man1/grep.1.html</a></p>

<h2><span class="inl_cmd">cat</span> – concatenate – sætte i kæde</h2>

<p><span class="inl_cmd">cat</span> laver et output af filen, men stopper ikke når skærmen er fyldt. Derfor er programmet ikke altid velegnet til at vise indholdet af filer. F.eks:</p>

<code class="cmd">cat /etc/hosts</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ cat /etc/hosts
127.0.0.1	localhost
127.0.1.1	tj-VirtualBox

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
</pre>

<p>man-page <span class="inl_cmd">cat</span>: 
	<a href="http://manpages.ubuntu.com/manpages/trusty/man1/cat.1.html" target="_blank">
	http://manpages.ubuntu.com/manpages/trusty/man1/cat.1.html</a></p>
	
<h2>Omdiriger output (redirect)</h2>

<p>Nogen gange har man brug for at omdirigere indhold. Det kan f.eks. være at indsætte et output i en fil. Til at omdirigere anvender man <span class="inl_cmd">&gt;</span> og <span class="inl_cmd">&gt;&gt;</span>. En pil erstatter alt indhold og 2 pile tilføjer. </p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>cat fil1 > fil2</td>
			<td>Erstat indholdet af fil2 med indholdet af fil1</td>
		</tr>
		<tr>
			<td>cat fil1 >> fil2</td>
			<td>Tilføj indholdet af fil1 til slutningen af fil2</td>
		</tr>
		<tr>
			<td>cat -n fil >> fil_med_numre</td>
			<td>sæt linienumre i file</td>
		</tr>
	</tbody>
</table>

<p>Omdirigering anvendes også til at omdirigere fejlmeddelelser. Se følgende skema</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>&gt; fil</td>
			<td>Sætter output ind i fil</td>
		</tr>
		<tr>
			<td>1 &gt; fil</td>
			<td>Sætter output ind i fil</td>
		</tr>
		<tr>
			<td>2 &gt; fil</td>
			<td>Sætter fejl-output ind i fil</td>
		</tr>
		<tr>
			<td>& &gt; fil</td>
			<td>sætter både rigtig og fejl-output ind i fil</td>
		</tr>
	</tbody>
</table>

<p>Man kan også sende output til <span class="inl_cmd">/dev/null</span>, som bedst kan beskrives som skraldespand. På den måde kan man fjerne meddelelser fra et program. Det kan være praktisk hvis man anvender kommandoer i scripts eller man ønsker at køre programmer usynligt i baggrunden. Herunder er et eksempel på anvendelse ved hjælp af <span class="inl_cmd">id</span>, hvor både et positivt output og et fejl output bliver omdirigeret til <span class="inl_cmd">/dev/null</span>.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ id tj
uid=1000(tj) gid=1000(tj) grupper=1000(tj),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)
tj@tj-VirtualBox:~$ id tj 1>/dev/null
tj@tj-VirtualBox:~$ id hugo 2>/dev/null
</pre>

<p>En sidste praktisk måde at anvende omdirigering er til at indsætte tekststrenge ved hjælp af <span class="inl_cmd">echo</span>. På denne måde kan man indsætte tekstrenge i filer:</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>echo "tekststreng" > *fil_navn*</td>
			<td>Sletter filens indhold og indsætter "tekststreng" som nyt indhold</td>
		</tr>
		<tr>
			<td>echo "tekststreng" >> *fil_navn*</td>
			<td>Indsæt "tekststreng" i bunden af en fil - anvendeligt til logs.</td>
		</tr>
	</tbody>
</table>

<p>Læs mere: <a href="http://askubuntu.com/questions/350208/what-does-2-dev-null-mean" target="_blank">
http://askubuntu.com/questions/350208/what-does-2-dev-null-mean</a></p>



<h2>Pipes</h2>

<p>Pipes er en måde at overføre output fra en kommando til en anden. Hvis man f.eks. vil finde ud af hvor mange gange bogstavkombinationen "lib" forekommer i filnavne på roden, vil kommandoen <span class="inl_cmd">ls</span> blot liste alt indholdet op.</p>

<pre class="ubuntu_terminal">
root@thoj:~#  ls /
bin    data  home            lib    lost+found  opt   run   sys  var
boot   dev   initrd.img      lib32  media       proc  sbin  tmp  vmlinuz
cdrom  etc   initrd.img.old  lib64  mnt         root  srv   usr  vmlinuz.old
</pre>

<p>Ved at anvende pibes (Den lodrette streg | ), kan vi "filtrere" output ved hjælp af <span class="inl_cmd">grep</span>.	</p>

<pre class="ubuntu_terminal">
root@thoj:~# ls / | grep lib
<span class="red">lib</span>
<span class="red">lib</span>32
<span class="red">lib</span>64
</pre>

<p>Pipen leder outputtet fra <span class="inl_cmd">ls /</span> ind i <span class="inl_cmd">grep</span>-kommandoen, som giver vores output.</p>

<p>Herunder er nogle flere eksempler med anvendelse af <span class="inl_cmd">grep</span>.</p>


<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>tail -10 /etc/passwd | grep var</td>
			<td>Find linier med forekomsten af tekststrengen "var" i de sidste 10 linier 
			af <span class="inl_cmd">/etc/passwd</span></td>
		</tr>
		<tr>
			<td>lspci | grep Ethernet</td>
			<td>Find informationer om dit netkort. Læg mærke til at søgningen er case-sensitiv 
			(det store E i "Ethernet").</td>
		</tr>
	</tbody>
</table>

<h2><span class="inl_cmd">sed</span> - Erstat indhold i filer</h2>

<p><span class="inl_cmd">sed</span> anvendes til at filtrere og transformere tekst i filer. Her vil vi kun se hvordan vi kan erstatte tekst ved hjælp af <span class="inl_cmd">sed</span>.</p>

<ol class="disc">
	<li>Opret <span class="inl_cmd">sedfil</span></li>
	
	<code class="cmd">touch sedfil</code>
	
	<li>Skriv tekst ind i filen</li>
	
	<code class="cmd">echo "Hej jeg hedder Kurt-Georg" > sedfil</code>
	
	<li>Erstat <span class="inl_cmd">Kurt-Georg</span> med dit eget navn</li>
	
	<code class="cmd">sed -i s/Kurt-Georg/Thomas/ sedfil</code>
	
</ol>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ touch sedfil
tj@tj-VirtualBox:~$ echo 'Mit navn er Kurt-Georg' > sedfil
tj@tj-VirtualBox:~$ cat sedfil
Mit navn er Kurt-Georg
tj@tj-VirtualBox:~$ sed -i s/Kurt-Georg/Thomas/ sedfil 
tj@tj-VirtualBox:~$ cat sedfil
Mit navn er Thomas
</pre>

<p><span class="inl_cmd">sed</span> er velegnet til at bruge i scripts.</p>

<h2><span class="inl_cmd">find</span> - Find mapper og filer</h2>

<p>For at søge efter filer og mapper anvendes kommandoerne <span class="inl_cmd">find</span> og <span class="inl_cmd">locate</span>. Hvis du ønsker at lave en søgning i hele filstrukturen bør du søge ved hjælp af sudo eller som root. Læg også mærke til at søgningen skelner mellem små og store bogstaver. En søgning på mappen apt giver flere resultater - APT giver ingen.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>find / -type f -name fstab</td>
			<td>Finder alle filer der hedder fstab</td>
		</tr>
		<tr>
			<td>find . -type d -name apt</td>
			<td>Finder alle mapper der hedder noget med apt i den mappe du står i.</td>
		</tr>
		<tr>
			<td>find . -type f -perm /a=x</td>
			<td>Finder alle filer der er eksekverbare i den mappe du står i</td>
		</tr>
		<tr>
			<td>find . -type d -empty</td>
			<td>Finder alle tomme mapper i den mappe du står i.</td>
		</tr>
	</tbody>
</table>

<p>man-page <span class="inl_cmd">more</span>: 
	<a href="http://manpages.ubuntu.com/manpages/trusty/en/man1/find.1.html" target="_blank">
	http://manpages.ubuntu.com/manpages/trusty/en/man1/find.1.html</a></p>
	
<p>Kommandoen find kan også anvendes til at søge og slette filer i samme kommando. Hvis du f.eks. har en mappe med både RAW og JPG billeder kan du med denne kommando slette alle jpg billederne</p>	
	
	<code class="cmd">find . -type f -name "*.JPG" -exec rm -f {} \;</code>
	
<p><span class="bold">VIGTIGT:</span> Som med alle andre slette kommandoer skal du være varsom, da du risikerer at slette mere end du ønsker. F.eks. vil et <span class="inl_cmd">/</span> i stedet for et <span class="inl_cmd">.</span> betyde at du sletter alle JPG billeder på harddisken, i stedet for dem der ligger i dine undermapper. Derfør bør du altid have styr på hvor i filstrukturen du er. Er du i tvivl så anvend <span class="inl_cmd">pwd</span>, så får du den fulde sti som output.</p>

<h2>Pakkede filer</h2>

<p>Der findes mange pakkeprogrammer til Linux, men et af de mest udbredte er <span class="inl_cmd">tar</span> (<span class="bold">T</span>ape <span class="bold">AR</span>chive). <span class="inl_cmd">tar</span> lægger som udgangspunkt filerne sammen i en lang fil, men kobineres ofte med komprimeringsalgoritmen <span class="inl_cmd">gzip</span>, og angives med .gz efter filnavnet.</p>

<p>Vær opmærksom på, at man som standard pakker mapper ned. Derfor kopierer/flytter man først de filer der skal transporteres ind i en mappe, hvorefter denne pakkes. Det er hvad modtageren forventer.</p>

<p>For at pakke noget ned anvendes:</p>

<code class="cmd">tar -cvzf *filnavn* *mappe der skal pakkes*</code>

<p>For at pakke ud (her tar.gz) anvendes:</p>

<code class="cmd">tar -xvzf *filnavn*.tar.gz</code>

<p><span class="inl_cmd">tar</span> og <span class="inl_cmd">gzip</span> er langt fra det bedste komprimeringsprogram, men det findes på alle Linuxsystemer som standard. Pakkeformatet <span class="inl_cmd">lzma</span> er et mere moderne format, hvor det kan lade sig gøre at konfigurere alt lige fra CPU-load til hukommelsesforbrug. Det har stor fordel når man anvender det i backup sammenhæng.</p>

<h1>Opret, slet,kopier, flytter filer og mapper</h1>

<p>For at kunne arbejde med filer i et Linuxsystem skal man have rettigheden til at gøre det. Nogle gange kan det være nødvendigt at ændre rettighederne for filer, f.eks. hvis man ønsker at give en anden bruger ejerskab til eller adgang til en bestemt fil. Herunder køres kommandoerne din brugers egen mappe.</p>

<h2><span class="inl_cmd">mkdir</span> – opret mapper</h2>

<p>Til at oprette mapper bruges kommandoen mkdir (make directory). <span class="inl_cmd">~</span> henviser til brugerens hjemmemappe.</p>

<p>Eksempel:</p>

<code class="cmd">mkdir ~/testmappe</code>

<p>Man kan også oprette flere mapper på en gang</p>

<code class="cmd">mkdir testmappe2 testmappe3 testmappe4</code>

<p>Vi ser mapperne med kommandoen: <span class="inl_cmd">ls -al | grep testmappe</span>.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ls -al | grep testmappe
drwxrwxr-x  2 tj   tj   4096 mar 15 20:18 <span class="red">testmappe</span>1
drwxrwxr-x  2 tj   tj   4096 mar 15 20:18 <span class="red">testmappe</span>2
drwxrwxr-x  2 tj   tj   4096 mar 15 20:18 <span class="red">testmappe</span>3
drwxrwxr-x  2 tj   tj   4096 mar 15 20:19 <span class="red">testmappe</span>4
</pre>

<p>Har man brug for at oprette en hel mappestruktur indsætter man et <span class="inl_cmd">-p</span> i kommanoen. Herunder vil vi oprette mappestien <span class="inl_cmd">testmappe5/undermappe/underundermappe</span>.</p>

<code class="cmd">mkdir -p  ~/testmappe5/undermappe/underundermappe</code>

<p>Vi anvender <span class="inl_cmd">tree</span> til at se mapperne</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ tree -L 3 ~/testmappe5
<span class="blue1">/home/tj/testmappe5</span>
└── <span class="blue1">undermappe</span>
    └── <span class="blue1">underundermappe</span>

2 directories, 0 files
</pre>


<h2><span class="inl_cmd">touch</span> – ændre tidsstempel/oprette filer</h2>

<p><span class="inl_cmd">touch</span> er en kommando der anvendes til at forny en fils tidstempel. På den måde kan se hvornår en fil sidst er kørt eller opdateret. Ofte bruger man også kommandoen til at oprette filer med, som vi gør herunder.</p>

<p>Eksempel:</p>

<code class="cmd">touch ~/testfil</code>

<p>Man kan også oprette en række af filer på en gang:</p>

<code class="cmd">touch ~/testfil2 ~/testfil3 ~/testfil4</code>

<p>Lad os få et overblik over de oprettede filer med kommandoen: <span class="inl_cmd">ls -al | grep testfil</span></p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ls -al | grep testfil
-rw-rw-r--  1 tj   tj      0 mar 15 20:06 <span class="red">testfil</span>
-rw-rw-r--  1 tj   tj      0 mar 15 20:08 <span class="red">testfil</span>2
-rw-rw-r--  1 tj   tj      0 mar 15 20:08 <span class="red">testfil</span>3
-rw-rw-r--  1 tj   tj      0 mar 15 20:08 <span class="red">testfil</span>4
</pre>

<p>Med den kommando filtrerer vi output fra <span class="inl_cmd">ls</span> med tekststrengen "testfil". Som du kan se er den første testfil 2 minutter bag de andre. Lad os opdatere dem alle til samme tidsstempel med <span class="inl_cmd">touch testfil*</span>.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ls -al | grep testfil
-rw-rw-r--  1 tj   tj      0 mar 15 20:14 <span class="red">testfil</span>
-rw-rw-r--  1 tj   tj      0 mar 15 20:14 <span class="red">testfil</span>2
-rw-rw-r--  1 tj   tj      0 mar 15 20:14 <span class="red">testfil</span>3
-rw-rw-r--  1 tj   tj      0 mar 15 20:14 <span class="red">testfil</span>4
</pre>

<h2><span class="inl_cmd">rm</span> – slette filer og mappper</h2>

<p>Til at slette filer og mapper anvendes kommandoen <span class="inl_cmd">rm</span> (remove). Det er god vane, at anvende den fulde sti til det man sletter, for at undgå at slette noget forkert.</p>

<p>Eksempel: Slet filen <span class="inl_cmd">testfil2</span> i din hjemmemappe der er oprettet ovenfor</p>

<code class="cmd">rm ~/testfil</code>

<p>For at slette en mappe skal man tilføje <span class="inl_cmd">-R</span> til kommandoen (-R betyder recursive)</p>

<p>Eksempel: slet <span class="inl_cmd">testmap1</span> og alle dens filer/undermapper der blev oprettet ovenfor</p>

<code class="cmd">rm -R ~/testmap1</code>

<p>Teoretisk set kan den kommando slette hele ens harddisk, hvis man får / til at stå alene, da det er roden på hele systemet. Heldigvis er der indbygget en "failsafe" i kommandoen, sådan at man skal tilføje <span class="inl_cmd">--no-preserve-root</span> som en option.</p>

<pre class="ubuntu_terminal">
root@thoj:~# rm -R /
rm: det er farligt at operere rekursivt på '/'
rm: brug --no-preserve-root for at tilsidesætte denne sikring
</pre>

<h2>Kopiere og flytte filer</h2>

<p>For at holde fast i overvejelserne ovenfor er kopiering af filer den første kommando vi skal lære.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>cp fil1 fil2</td>
			<td>Laver en kopi af fil1 i fil2</td>
		</tr>
		<tr>
			<td>cp -R ~/dir1 ~/dir2</td>
			<td>Laver en kopi af dir1 i dir2</td>
		</tr>
		<tr>
			<td>mv fil1 fil2</td>
			<td>Ændrer fil1 til at hedde fil2</td>
		</tr>
		<tr>
			<td>mv ~/dir1 ~/dir2</td>
			<td>Flytter indholdet af dir1 til dir2 (dir1 forsvinder)</td>
		</tr>
	</tbody>
</table>

<p>Læg mærke til at man flytter filer og mapper for at ændre deres navne.</p>

<p>Hvis du ønsker at være sikker på at kunne vende tilbage til din gamle konfiguration kan du altså blot lave en kopi af den fil du redigerer i og navngive kopien med et sigende efternavn f.eks.</p>

<code class="cmd">cp ~/testfil ~/testfil.backup </code>

<p>På denne måde kan du hurtigt gå tilbage til den oprindelige opsætning ved at køre kommandoen modsat.</p>

<code class="cmd">cp ~/testfil.backup ~/testfil </code>

<blockquote class="center">
		<span class="bold">HUSK</span>: Rigtige mænd tager ikke backup – de græder bare.
</blockquote>

<h2>Hente filer på nettet</h2>

<p>For at hente filer på nettet anvendes programmet <span class="inl_cmd">wget</span>. For at hente filer på nettet skal du kende deres adresse. Herunder hentes Linux distributionen TinyCorePlus til computeren.</p>

<code class="cmd">wget -c http://tinycorelinux.net/6.x/x86/release/CorePlus-current.iso</code>

<p><span class="inl_cmd">-c</span> gør sådan, at hvis filhentningen afbrydes, så vil den kunne fortsætte fra hvor forbindelsen blev afskåret. Vær opmærksom på, at den hentede fil bliver gemt i den samme mappe som du kørte kommandoen i.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>wget -c *filadresse*</td>
			<td>Henter filen, med mulighed for at genstarter hentningen.</td>
		</tr>
		<tr>
			<td>wget -P ~/*mappe* *filadresse*</td>
			<td>Henter filen, men gemmer den i mappen ~/*mappe*</td>
		</tr>
		<tr>
			<td>wget -o ~/*hentetfil* *filadresse*</td>
			<td>Henter filen, men gemmer den som "hentetfil*</td>
		</tr>
		<tr>
			<td>wget -b *filadresse*</td>
			<td>Henter filen i baggrunden - frigiver kommandolinien med det samme.</td>
		</tr>
	</tbody>
</table>

<p>Optionerne kan stackes. På den måde vil <span class="inl_cmd">wget -cob minfil *filadresse*</span> hente i baggrunden, gemme den som minfil og sikre at download kan genoptages ved afbrydelse.</p>

<p>man-page <span class="inl_cmd">wget</span>: 
	<a href="http://manpages.ubuntu.com/manpages/trusty/man1/wget.1.html" target="_blank">
	http://manpages.ubuntu.com/manpages/trusty/man1/wget.1.html</a></p>

<h1>Genstart og luk computeren</h1>

<p>En server lukkes ned med kommandoen:</p>

<code class="cmd">shutdown [Optioner] tid [besked]</code>

<p>Eksempel</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>shutdown -h 0</td>
			<td>Computeren lukkes ned nu</td>
		</tr>
		<tr>
			<td>shutdown -h 10 Computeren lukkes ned om 10 minutter</td>
			<td>Computeren lukkes ned om 10 minutter med budskabet ”Computeren lukkes ned om 10 minutter”</td>
		</tr>
		<tr>
			<td>shutdown -r 0</td>
			<td>Serveren genstartes om 0 minutter</td>
		</tr>
	</tbody>
</table>

<p>Man kan også vælge at anvende <span class="inl_cmd">reboot</span>. Kommandoen genstarter blot computeren.</p>

<code class="cmd">reboot</code>


<p>man-page: <span class="inl_cmd">shutdown</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man8/shutdown.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man8/shutdown.8.html</a></p>

<p>man-page: <span class="inl_cmd">reboot</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/man8/reboot.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man8/reboot.8.html</a></p>

<h1>Rettigheder</h1>

<p>I Linux er der 3 grundlæggende 3 rettigheder vi kan sætte på filer og mapper: read, write og execute (læse, skrive og udføre).</p>

<table class="">
	<thead>
		<tr>
			<th>Rettighed</th>
			<th>Forklaring</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Read (læse)</td>
			<td>man kan tilgå filen (se og åbne den) og dermed læse hvad der står i den.</td>
		</tr>
		<tr>
			<td>Write (skrive)</td>
			<td>Man kan skrive i filen. Hvis der ikke er sat read rettigheder, kan man hverken åbne filen eller se indholdet</td>
		</tr>
		<tr>
			<td>Execute (udførelse)</td>
			<td>Filen kan tolkes som et program og derfor køres af operativsystemet.</td>
		</tr>
	</tbody>
</table>

<p>Ved hjælp af disse 3 parametre styres alle filer, mapper og enheder på computere. Lad os kigge på et eksempel nemlig <span class="inl_cmd">/etc/passwd</span> som er den fil der styrer brugerne på Linux .</p>

<code class="cmd">ls -al /etc/passwd</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ls -al /etc/passwd
-rw-r--r-- 1 root root 2013 mar 16 20:05 /etc/passwd
</pre>

<p>Den linie giver os alle de informationer om rettigheder vi har behov for</p>

<table class="cmd_table">
	<tbody>
		<tr>
			<td>-rw-r--r--  </td>
			<td>Oversigt over filens retttigheder</td>
		</tr>
		<tr>
			<td>1</td>
			<td>Antal af henvisninger til filen</td>
		</tr>
		<tr>
			<td>root root</td>
			<td>Brugeren og gruppen</td>
		</tr>
		<tr>
			<td>2013</td>
			<td>Filens størrelse</td>
		</tr>
		<tr>
			<td>mar 16 20:05</td>
			<td>tidsstempel</td>
		</tr>
		<tr>
			<td>/etc/passwd</td>
			<td>Filens navn</td>
		</tr>
	</tbody>
</table>

<p>Læg mærke til, at der både findes en bruger og en gruppe der hedder <span class="inl_cmd">root</span>. Det gælder for alle brugere på Linux.</p>

<p>Rettighederne aflæses som følger</p>

<table class="centreret">
	<thead>
		<tr>
			<th>Filtype</th>
			<th colspan="3">Bruger</th>
			<th colspan="3">Gruppe</th>
			<th colspan="3">Alle</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>type</td>
			<td>read</td>
			<td>write</td>
			<td>execute</td>
			<td>read</td>
			<td>write</td>
			<td>execute</td>
			<td>read</td>
			<td>write</td>
			<td>execute</td>			
		</tr>
		<tr>
			<td>-</td>
			<td>r</td>
			<td>w</td>
			<td>-</td>
			<td>r</td>
			<td>-</td>
			<td>-</td>
			<td>r</td>
			<td>-</td>
			<td>-</td>			
		</tr>

	</tbody>
</table>

<p>Vi kan altså sige om denne fil at brugeren er <span class="inl_cmd">root</span>, som må læse og skrive i filen. Alle andre (gruppe og alle). De er nødvendigt for alle at kunne læse denne fil, da det er den der administrere adgangen til systemet. Kigger vi ind i filen kan vise hvad den har at sige om vores bruger, her <span class="inl_cmd">tj</span>. Da alle har ret til at læse i filen kan jeg kommandoen den som mig selv.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:/home$ cat /etc/passwd | grep tj
<span class="red">tj</span>:x:1000:1000:Thomas Jensen,,,:/home/<span class="red">tj</span>:/bin/bash
</pre>

<p>Den linie fortæller os om vores bruger, hvilket bruger- og gruppe id man har, ens hjemmemappe og hvilken kommandofortolker vi har adgang til. Det lille x i starten henviser til vores kodeord, som er lagret i filen <span class="inl_cmd">/etc/shadow</span>.</p>

<p>Et andet eksempel er den partition der blev oprettet under installationen (<span class="inl_cmd">/data</span>). vi kan se rettighedern ved at køre : <span class="inl_cmd">ls -al / | grep data</span></p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ls -al / | grep data
drwxr-xr-x   3 root root  4096 mar 15 18:13 <span class="red">data</span>
</pre>

<p>Det første der skal gøres er, at root skal overdrage sine rettigheder til dig, og det vil i mit tilfælde sige at der skal gøres følgende to kommandoer</p>

<code class="cmd">sudo chown -R thoj:thoj /data</code>
<code class="more_cmd">sudo chmod -R 700 /data</code>

<p>Kommandoerne vil blive gennemgået herunder.</p>

<h2>Superbrugeren</h2>

<p><span class="inl_cmd">root</span>-brugeren er ikke underlagt de rettigheder der er sat på på de enkelte filer. <span class="inl_cmd">root</span> kan og skal kunne alt. At have <span class="inl_cmd">root</span>-rettigheder på et system handler ikke kun om at man er god til Linux, men forudsætter også at man gør sig overvejelser om hvad man bruger disse rettigheder til.</p>

<p>Den danske grundlov (<a href="http://grundloven.dk/" target="_blank">http://grundloven.dk/</a>) siger følgende:</p>

<blockquote>
	
	<p><span class="bold">§ 72</span></p>

	<p>Boligen er ukrænkelig. Husundersøgelser, beslaglæggelse og undersøgelse af breve og andre papirer samt brud på post-, telegraf- og telefonhemmeligheden må, hvor ingen lov hjemler en særegen undtaglse, alene ske efter en retskendelse. 
	</p>
	
</blockquote>

<p>Grundloven har gode retningslinier til superbrugeren. Du må alt der ikke krænker brugeren, dvs. hjælpe brugeren med at løse sin opgave. Det gælder også selvom brugeren er dit barn, din partner eller kollega.</p>

<p>Den eneste undtagelse er, når brugeren har fået at vide at det ikke er brugerens private ejendom, f.eks. hvor en virksomhed eller skole stiller ressourcen til rådighed for dig.</p>

<h2><span class="inl_cmd">chown</span> – change owner</h2>

<p>Chown er den hurtige løsning hvis du ønsker at ændre ejeren og gruppen af en fil eller en mappe.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>chown thoj ~/testfil</td>
			<td>Ændrer ejerskabet af <span class="inl_cmd">~/testfil</span> til brugeren thoj</td>
		</tr>
		<tr>
			<td>chown thoj:testgruppe ~/testfil</td>
			<td>Ændrer ejerskabet af <span class="inl_cmd">~/testfil</span> til brugeren thoj og gruppen testgruppe</td>
		</tr>
		<tr>
			<td>chown -R thoj /data</td>
			<td>Ændre ejerskabet af alle filer og undermapper i /data til thoj</td>
		</tr>
	</tbody>
</table>

<p>man-page: <span class="inl_cmd">chown</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/man1/chown.1.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man1/chown.1.html</a></p>


<h2><span class="inl_cmd">chgrp</span></h2>

<p>Ligesom ovenfor, men virker på grupper</p>

<h2><span class="inl_cmd">chmod</span></h2>



<p>chmod ændrer rettighederne til filen og kommandoen udføres som nedenfor. Husk at anvende <span class="inl_cmd">sudo</span> hvis du ikke har rettighederne til filen:</p>

<code class="cmd">chmod [-R][rettigheder] [fil/mappe]</code>

<p>Skal det gælde alle undermapper indsættes -R (recursiv)</p>

<p>Rettighederne kan sættes enten ved hjælp af tal eller bogstaver. Det er min anbefaling at du lærer at anvende tal til det!</p>

<h2><span class="inl_cmd">chmod</span> - med tal (anbefalet metode)</h2>

<p>Rettigheder kan også sættes for den enkelte kategori med en tal værdi der præsenterer summen af de binære tal.</p>

<table class="centreret">

	<thead>
		<tr>
			<th>Bruger</th>
			<th>Gruppe</th>
			<th>Andre</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>[ 0 - 7 ]</td>
			<td>[ 0 - 7 ]</td>
			<td>[ 0 - 7 ]</td>			
		</tr>
	</tbody>
</table>

<p>Værdierne fra 0-7 fremkommer ved at der bruges 3 bit til at sætte brugerens, gruppens og alles rettigheder med.</p> 

<table class="centreret">
	<thead>
		<tr>
			<th>Filtype</th>
			<th colspan="3">Bruger</th>
			<th colspan="3">Gruppe</th>
			<th colspan="3">Alle</th>
		</tr>
	</thead>
	<tbody>
		<tr><td>-</td>
			<td>r</td>
			<td>w</td>
			<td>x</td>
			<td>r</td>
			<td>w</td>
			<td>x</td>
			<td>r</td>
			<td>w</td>
			<td>x</td>			
		</tr>
		<tr>
			<td></td>
			<td>read</td>
			<td>write</td>
			<td>execute</td>
			<td>read</td>
			<td>write</td>
			<td>execute</td>
			<td>read</td>
			<td>write</td>
			<td>execute</td>			
		</tr>
	</tbody>
</table>


<p>Værdierne sættes efter nedestående skema:</p>

<table class="centreret">
	<thead>
		<tr>
			<th>Talværdi</th>
			<th>r <br/> 2² = 4</th>
			<th>w <br/> 2¹ = 2</th>
			<th>x <br/> 2⁰ = 1</th>
			<th>Rettigheder</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>7</td>
			<td>1</td>
			<td>1</td>
			<td>1</td>
			<td>Alle (læse, skrive og udføre)</td>
		</tr>
		<tr>
			<td>6</td>
			<td>1</td>
			<td>1</td>
			<td>0</td>
			<td>Læse og skrive</td>
		</tr>
		<tr>
			<td>5</td>
			<td>1</td>
			<td>0</td>
			<td>1</td>
			<td>Læse og udføre</td>
		</tr>
		<tr>
			<td>4</td>
			<td>1</td>
			<td>0</td>
			<td>0</td>
			<td>Læse</td>
		</tr>
		<tr>
			<td>3</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
			<td>Skrive og udføre</td>
		</tr>
		<tr>
			<td>2</td>
			<td>0</td>
			<td>1</td>
			<td>0</td>
			<td>Skrive</td>
		</tr>
		<tr>
			<td>1</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>udføre</td>
		</tr>
		<tr>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>Ingen</td>
		</tr>		
	</tbody>
</table>

<p>Eksempler</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>chmod 660 testfil</td>
			<td>Kun brugeren og gruppen har læse og skriverettigheder.</td>
		</tr>
		<tr>
			<td>chmod 700 testfil</td>
			<td>Fjerner alle rettigheder fra gruppen og andre</td>
		</tr>
		<tr>
			<td>chmod -R 705 /var/www/html</td>
			<td>Giver brugeren alle rettigheder til alle filer og undermapper i <span class="inl_cmd">/var/www/html</span>.Alle kan læse og afvikle programmer. Dette er f.eks. indstillingen man anvender på de filer er skal være tilgængelig på en webserver (<span class="inl_cmd">/var/www/html</span> er Apaches standardmappe).</td>
		</tr>
	</tbody>
</table>

<p>Vær opmærksom på, at man ikke kan fratage root' rettigheder til en fil/mappe. Selvom man køre en <span class="inl_cmd">chmod 000</span> vil root stadig kunne tilgå dem og sætte nye rettigheder. Når man anvender Windows er det muligt at fjerne al adgang til en fil når man anvender et Windows styresystem.</p>


<p>man-page: <span class="inl_cmd">chmod</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/man1/chmod.1.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man1/chmod.1.html</a></p>

<h2><span class="inl_cmd">chmod</span> - med bogstaver</h2>

<p><span class="bold">NOTE</span>: Dette afsnit er medtaget, da man stadig finder guides på nettet der anvender denne metode. Jeg synes dog at den er for omstændig og kan hurtig blive uoverskuelig.</p>

<p>Rettigheder sættes ved at angive hvem og hvilke rettigheder det handler om efter følgende skema. Det kan gøres på to måder: Med bogstaver og med tal.</p>

<table class="">
	<tbody>
		<tr>
			<td>u</td>
			<td>Bruger (user)</td>
			<td>Ejerens rettigheder</td>
		</tr>
		<tr>
			<td>g</td>
			<td>Gruppe (group)</td>
			<td>Gruppens rettigheder</td>
		</tr>
		<tr>
			<td>o</td>
			<td>Andre (others)</td>
			<td>Rettigheder der gælder alle.</td>
		</tr>
		<tr>
			<td>a</td>
			<td>Alle (all)</td>
			<td>Alle ovenstående. ved at bruge a giver man alle samme rettigheder</td>
		</tr>
	</tbody>
</table>

<p><span class="inl_cmd">+</span> tilføjer rettigheder, <span class="inl_cmd">-</span> trækker fra og <span class="inl_cmd">=</span> sætter dem lig med, som du kan se i eksemplerne herunder.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>chmod o+rw testfil</td>
			<td>Giver andre skrive og læse rettigheder til testfil</td>
		</tr>
		<tr>
			<td>chmod go= testfil</td>
			<td>Fjerner alle rettigheder fra gruppen og andre</td>
		</tr>
		<tr>
			<td>chmod -R ug+rw /data</td>
			<td>Giver brugeren og gruppen læse og skrive rettigheder til alle filer og undermapper i <span class="cmd">/data</span></td>
		</tr>
	</tbody>
</table>


<h1>Brugere og grupper</h1>

<p>Alle rettigheder i Linux er sat ud fra ejerskab. Tilgængeligheden af filer, mapper og enheder bliver styret af disse brugerrettigigheder </p>

<h2><span class="inl_cmd">adduser</span> og <span class="inl_cmd">deluser</span> - Oprette og slette brugere</h2>

<p>Man opretter og sletter brugere med kommandown <span class="inl_cmd">adduser</span>. Herunder opretter jeg brugeren <span class="inl_cmd">testuser</span>.</p>

<code class="cmd">sudo adduser testuser</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo adduser testuser
[sudo] password for tj: <span class="red">&lt;-- Indtast dit kodeord</span>
Tilføjer bruger »testuser«...
Tilføjer ny gruppe »testuser« (1001)...
Tilføjer ny bruger »testuser« (1001) med gruppe »testuser«...
Opretter hjemmemappe »/home/testuser«...
Kopierer filer fra »/etc/skel«...
Indtast ny UNIX-adgangskode: <span class="red">&lt;-- indtast den nye bruger password</span>
Genindtast ny UNIX-adgangskode: <span class="red">&lt;-- skriv det igen</span>
passwd: adgangskoden blev opdateret
Ændrer brugeroplysninger for testuser
Angiv ny værdi eller tryk RETUR for standardværdien
	Fulde navn []: <span class="red">[Retur]</span>
	Værelsesnummer []: <span class="red">[Retur]</span>
	Arbejdstelefon []: <span class="red">[Retur]</span>
	Telefon []: <span class="red">[Retur]</span>
	Andet []: <span class="red">[Retur]</span>
Er informationerne korrekte? [J/n] <span class="red">[Retur]</span>
</pre>

<p>Kontroller at han er blevet oprettet:</p>

<code class="cmd">cat /etc/passwd | grep testuser</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ cat /etc/passwd | grep testuser
<span class="red">testuser</span>:x:1001:1001:,,,:/home/<span class="red">testuser</span>:/bin/bash
</pre>


<p>For at slette en bruger anvendes kommandoen <span class="inl_cmd">deluser</span></p>

<code class="cmd">sudo deluser testuser</code>

<p>Anvender man ovenstående kommando bliver brugerens hjemmemappe ikke slettet. For at slette alle brugerens filer skal der tilføjes<span class="inl_cmd">--remove-home</span>.</p>

<p>man-page <span class="inl_cmd">adduser</span>: 
<a href="http://manpages.ubuntu.com/manpages/trusty/man8/adduser.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man8/adduser.8.html</a></p>

<p>man-page <span class="inl_cmd">deluser</span>: 
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man8/deluser.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man8/deluser.8.html</a></p>

<h2><span class="inl_cmd">useradd</span></h2>

<p>Når man anvender <span class="inl_cmd">userad</span> er det egentlig en scriptfil der arbejder med kommandoen <span class="inl_cmd">useradd</span>. <span class="inl_cmd">useradd</span> giver mulighed for at man kan sætte en bruger op i detaljer med en længere kommando. Kommanden anvendes ved at man tilføjer konfigurationen bagefter. Man skal huske at tilføje et password til brugeren bagefter. Se følgende eksempel:</p>

<code class="cmd">sudo useradd -d /home/testuser2 -m testuser2 -u 2010 -s /bin/bash</code>

<code class="more_cmd">sudo passwd testuser2</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo useradd -d /home/testuser2 -m testuser2 -u 2010 -s /bin/bash
tj@tj-VirtualBox:~$ sudo passwd testuser2
Indtast ny UNIX-adgangskode: <span class="red">&lt;-- indtast password f.eks. 123qwe</span>
Genindtast ny UNIX-adgangskode: <span class="red">... og igen</span>
passwd: adgangskoden blev opdateret
</pre>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ cat /etc/passwd | grep testuser
<span class="red">testuser</span>:x:1001:1001:,,,:/home/<span class="red">testuser</span>:/bin/bash
<span class="red">testuser</span>2:x:2010:2010::/home/<span class="red">testuser</span>2:/bin/bash
</pre>

<p>Kommandoen gør følgende:</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>-d /home/testuser2</td>
			<td>Opretter brugeren <span class="inl_cmd">test01</span> og registrerer hans hjemmemappe som <span class="inl_cmd">/home/testuser2</span>. Selve hjemmemappen er ikke oprettet</td>
		</tr>
		<tr>
			<td>-m testuser2</td>
			<td>Opretter mappen /home/testuser2</td>
		</tr>
		<tr>
			<td>-u 2010</td>
			<td>Giver brugeren UserID 2010</td>
		</tr>
		<tr>
			<td>-s /bin/bash</td>
			<td>Giver brugeren bin-bash som komandofortolker</td>
		</tr>
	</tbody>
</table>

<p><span class="inl_cmd">useradd</span> giver mulighed for at installere brugere med specifikke indstillinger og kan anvendes til at oprette mange brugere ved hjælp af scripting.</p>


<p>man-page <span class="inl_cmd">useradd</span>: 
<a href="http://manpages.ubuntu.com/manpages/trusty/man8/useradd.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man8/useradd.8.html</a></p>

<h2><span class="inl_cmd">id</span> - Findes brugeres</h2>

<p>For at checke om en bruger findes anvendes <span class="inl_cmd">id</span>.</p>

<code class="cmd">id *brugernavn*</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ id tj
uid=1000(tj) gid=1000(tj) grupper=1000(tj),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)
tj@tj-VirtualBox:~$ id hugo
id: hugo: ingen sådan bruger
</pre>



<h2><span class="inl_cmd">usermod</span></h2>

<p><span class="inl_cmd">usermod</span> anvendes til at ændre på brugerens konto.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>usermod -L testuser2</td>
			<td>Lås testuser2' konto</td>
		</tr>
		<tr>
			<td>usermod -U testuser2</td>
			<td>Åbn testuser2' konti</td>
		</tr>
	</tbody>
</table>

<p>man-page <span class="inl_cmd">usermod</span>: 
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man8/usermod.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man8/usermod.8.html</a></p>

<h2><span class="inl_cmd">chage</span></h2>

<p><span class="inl_cmd">chage</span> anvendes til at konfigurere brugerens password og måden de skal fornys på. Hvis man ønsker at få et overblik over hvordan brugerens indstillinger kan man anvende kommandoen: </p>

<code class="cmd">sudo chage -l testuser2</code>

<p>Herunder er et eksemel på resultatet</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo chage -l testuser2
Sidste ændring af adgangskode					: mar 16, 2016
Adgangskode udløber					: aldrig
Adgangskode inaktiv					: aldrig
Konto udløber						: aldrig
Minimalt antal dage mellem ændring af adgangskoden		: 0
Maksimalt antal dage mellem ændring af adgangskoden		: 99999
Antal dages forvarsel om adgangskodens udløb	: 7
</pre>

<p>Hvis man ønsker at ændre den måde brugerens password er sat op kan man køre nedestående kommando. Værdierne der angives er dage</p>

<code class="cmd">sudo chage testuser2</code>

<p>Herunder er et eksempel på resultatet af denne kommando, kørt på brugeren "chagetest"</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo chage testuser2
Ændrer forældelsesoplysninger for testuser2
Angiv ny værdi eller tryk RETUR for standardværdien

	Minimal alder for adgangskode [0]: <span class="red">&lt;-- ny værdi eller [Enter]</span>
	Maksimal alder for adgangskode [99999]: <span class="red">&lt;-- ny værdi eller [Enter]</span>
	Sidste ændring af adgangskode (ÅÅÅÅ-MM-DD) [2016-03-16]: <span class="red">&lt;-- ny værdi eller [Enter]</span>
	Advarsel om udløb af adgangskode [7]: <span class="red">&lt;-- ny værdi eller [Enter]</span>
	Adgangskode inaktiv [-1]: <span class="red">&lt;-- ny værdi eller [Enter]</span>
	Udløbsdato for konto (ÅÅÅÅ-MM-DD) [-1]: <span class="red">&lt;-- ny værdi eller [Enter]</span>
</pre>

<p>Hvis man ønsker at brugeren skal ændre sit passeword wed første login kan man anvende kommandoen <span class="inl_cmd">chage</span> med en option. Herunder laver vi ændringen for <span class="inl_cmd">testuser2</span></p>

<code class="cmd">sudo chage -d 0 testuser2</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo chage -d 0 testuser2
tj@tj-VirtualBox:~$ su testuser2
Adgangskode: 
Du skal omgående ændre din adgangskode (gennemtvunget af roden)
Ændrer adgangskode for testuser2.
(nuværende) UNIX-adgangskode: 
Indtast ny UNIX-adgangskode: 
Genindtast ny UNIX-adgangskode: 
testuser2@tj-VirtualBox:/home/tj$
</pre>

<p>man-page <span class="inl_cmd">chage</span>: 
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man1/chage.1.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man1/chage.1.html</a></p>


<h2>Administration af grupper</h2>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Addgroup testgruppe</td>
			<td>Tilføjer gruppen testgruppe</td>
		</tr>
		<tr>
			<td>Delgroup testgruppe</td>
			<td>Fjerner testgruppe</td>
		</tr>
		<tr>
			<td>Adduser test testgruppe</td>
			<td>Tilføjer brugeren test til gruppen testgruppe</td>
		</tr>
		<tr>
			<td>Deluser test testgruppe</td>
			<td>Fjerner brugeren test fra gruppe testgruppe</td>
		</tr>
	</tbody>
</table>

<p>Manpages til add- og delgroup er de samme som add- og deluser.</p>

<p>Grupperne og deres medlemmer kan ses i filen <span class="inl_cmd">/etc/group</span>.</p>

<h2><span class="inl_cmd">sudo</span>-gruppen</h2>

<p>For at en bruger kan udføre administrationsarbejde skal han være medlem af sudo gruppen. Det gøres med følgende kommando:</p>

<code class="cmd">sudo adduser *brugernavn* sudo </brugernavn></code>

<p>Hvis man tilføjer en bruger gennem en terminal der er startet på en desktop skal man genstarte GUI'en, dvs. logge af og på igen. Det skyldes at GUI terminalen kører under samme session som GUI'en. For at genindlæse rettigheder osv. bliver man altså nød til at logge af og på igen.</p>





<h1>Redigering af filer</h1>

<p>På en Linuxserver bliver alle tjenester og hardware initialiseret og konfigureret igennem tekstfiler. Derfor skal du kende nano, et effektiv terminal tekstredigeringsprogram. Programmet har også farvekodning, hvis det genkender formatet. nano startes med kommandoen: </p>

<code class="cmd">nano *filnavn*</code>

<p>Herefter bliver ændres terminalen til nedestående, hvor menuen ligger i bunden af skærmen.</p>

<pre class="ubuntu_terminal">
<span class="white_bg">  GNU nano 2.2.6                New Buffer                                                          </span>











<span class="white_bg">^G</span> Get Help      <span class="white_bg">^O</span> WriteOut      <span class="white_bg">^R</span> Read File     <span class="white_bg">^Y</span> Prev Page     <span class="white_bg">^K</span> Cut Text      <span class="white_bg">^C</span> Cur Pos
<span class="white_bg">^X</span> Exit          <span class="white_bg">^J</span> Justify       <span class="white_bg">^W</span> Where Is      <span class="white_bg">^V</span> Next Page     <span class="white_bg">^U</span> UnCut Text    <span class="white_bg">^T</span> To Spell
</pre>

<p>Du navigerer rundt i nano med piletaster og tabulatorknappen. Programmets funktioner tilgår du med en kombination af [Ctrl] og et bogstav. Det bliver af nano angivet som f.eks. ^X</p>

<p>Kommandoerne er selvforklarende, men herunder er de meste basale funktioner</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><kbd>Ctrl</kbd>+<kbd>w</kbd></td>
			<td>Find</td>
		</tr>
		<tr>
			<td><kbd>Ctrl</kbd>+<kbd>y</kbd></td>
			<td>En side op</td>
		</tr>
		<tr>
			<td><kbd>Ctrl</kbd>+<kbd>v</kbd></td>
			<td>En side ned</td>
		</tr>
		<tr>
			<td><kbd>Ctrl</kbd>+<kbd>w</kbd>+<kbd>v</kbd></td>
			<td>Til filens sidste linie</td>
		</tr>
		<tr>
			<td><kbd>Ctrl</kbd>+<kbd>k</kbd></td>
			<td>Klip</td>
		</tr>
		<tr>
			<td><kbd>Ctrl</kbd>+<kbd>u</kbd></td>
			<td>Indsæt</td>
		</tr>
		<tr>
			<td><kbd>Ctrl</kbd>+<kbd>x</kbd></td>
			<td>Afslut nano</td>
		</tr>
	</tbody>
</table>

<p>Når du har redigeret din tekst færdig afslutter du med <kbd>Ctrl</kbd>+<kbd>x</kbd>, hvorefter nano i bunden svarer:</p>

<pre class="black">

    
<span class="white_bg">Save modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ? </span>	
<span class="white_bg"> Y</span> Yes
<span class="white_bg"> N</span> No           <span class="white_bg">^C</span> Cancel
</pre>


<p>Når du svarer y vil nano skrive filnavnet med den fulde sti, hvortil du taster <kbd>Enter</kbd>.</p>

<h1>Programadministration</h1>

<h2><span class="inl_cmd">apt-get</span> - program administration og vedligeholdelse</h2>

<p>Ubuntu anvender Debians pakkesystem <span class="inl_cmd">dpkg</span> (Debian package management system), som bliver administreret af programmet <span class="inl_cmd">apt</span> (Advances Packaging tool). Gevinsten ved at bruge kommandolinien er et stærkt og fleksibelt værktøj til at administrere ens programmer.</p>

<p><span class="inl_cmd">apt</span> har en konfigurationsfil (<span class="inl_cmd">/etc/apt/sources.list</span>), der henviser til nogle repositories (programbiblioteker) på Internettet. Når man beder <span class="inl_cmd">apt</span> om at installeret et program søger det efter filerne i disse repositories. Man kan tilføje flere repositories enten ved at tilføje dem til <span class="inl_cmd">/etc/apt/sources.list</span> eller ved at tilføje PPA'er (<span class="bold">P</span>ersonal <span class="bold">P</span>ackage <span class="bold">A</span>rchieve) som er mindre pakkearkiver oprettet af private eller programudbydere.</p>

<p>Eksempler:</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>apt-get update</td>
			<td>Synkroniserer din lokale apt med dine repositories.</td>
		</tr>
		<tr>
			<td>apt-get upgrade</td>
			<td>Opgraderer alle programmer på computeren som apt kontrollerer.</td>
		</tr>
		<tr>
			<td>apt-get upgrade -y</td>
			<td>Som ovenfor, men udfører kommandoen automatisk. Alle kommandoerne kan køres med -y</td>
		</tr>
		<tr>
			<td>apt-get dist-upgrade</td>
			<td>Opgraderer programmer samt de nødvendige programmer til den nyeste version der findes i <span class="inl_cmd">/etc/apt/sources.list</span> også selvom det ikke er din servers foretrukne version af programmet.</td>
		</tr>
		<tr>
			<td>apt-get remove [program]</td>
			<td>Fjerner [program]</td>
		</tr>
		<tr>
			<td>apt-get purge [program]</td>
			<td>Fjerner program og alle dets filer - også konfigurationsfiler</td>
		</tr>
		<tr>
			<td>apt-get autoremove</td>
			<td>Gennemgår apt og fjerner alle filer der ikke er i brug.</td>
		</tr>
		<tr>
			<td>dpkg --configure -a</td>
			<td>Det sker at apt-get ikke kan anvendes fordi noget er låst (f.eks. hvis en proces er blevet afbrudt. Denne kommando reconfigurerer pakkesystemet.</td>
		</tr>
	</tbody>
</table>

<p>Man bør opdatere sine repositories og have alle programmer på computeren opdateret før man installerer nye programmer. Det er især vigtigt at opdatere hvis man lige har tilføjet  nye repositories eller PPA'er, da de ellers ikke vil blive anvendt.</p>

<p>man-page: <span class="inl_cmd">apt-get</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man8/apt-get.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man8/apt-get.8.html</a></p>

<h2>Når <span class="inl_cmd">apt</span> fejler</h2>

<p>Det hænder at <span class="inl_cmd">apt</span> fejler. Når dette sker kan det være nødvendigt at få <span class="inl_cmd">apt</span> til at reconfigurere sig selv. Det gøres med kommandoen:</p>

<code class="cmd">dpkg --configure -a</code>

<p>Når <span class="inl_cmd">apt</span> er geninitialiseret kan man genstarte processen med kommandoen, hvor -f står for "fix broken":</p>

<code class="cmd">sudo apt-get install -f</code>

<h2>Administration af tjenester på serveren</h2>

<p>Generelt administreres tjenester på på Ubuntu med service kommandoen. Den fungerer efter nedestående skabelon:</p>

<code class="cmd">service [tjeneste] {start|stop|reload|restart|force-reload|status}</code>

<p>Ønsker du f.eks. at genstarte <span class="cmd_inl">bind9</span> tjenesten gøres det med kommandoen:</p>

<code class="cmd">service bind9 restart</code>

<p>For at tjekke om en tjeneste kører</p>

<code class="cmd">service bind9 status</code>

<p>man-page: <span class="inl_cmd">service</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man8/service.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man8/service.8.html</a></p>

<h2>Fjerne overflødige kerner</h2>

<p>Ubuntu beholder de gamle kerner der ligger på systemet, så de kan anvendes til at boote med. Dette er en sikkerhedsfeature, da man risikerer at nye kerner indeholder fejl, eller mangler funktionalitet som dine programmer anvender. De fylder dog en del.</p>

<p>De kan fjernes med følgende kommando (en linie):</p>

<code class="cmd">sudo apt-get purge $(dpkg -l linux-{image,headers}-"[0-9]*" | awk '/ii/{print $2}' | grep -ve $(uname -r | sed -r 's/-[a-z]+//') | sed ':a;N;$!ba;s/\n/ /g')</code>

<pre class="ubuntu_terminal">
thoj@thoj-VirtualBox:~$ sudo apt-get purge $(dpkg -l linux-{image,headers}-"
[0-9]*" | awk '/ii/{print $2}' | grep -ve $(uname -r | sed -r 's/-[a-z]+//') 
| sed ':a;N;$!ba;s/\n/ /g')
Indlæser pakkelisterne... Færdig
Opbygger afhængighedstræ        
Læser tilstandsoplysninger... Færdig
Følgende pakker vil blive AFINSTALLERET:
  linux-generic-lts-utopic* linux-headers-3.16.0-30*
  linux-headers-3.16.0-30-generic* linux-headers-3.16.0-46*
  linux-headers-3.16.0-46-generic* linux-headers-generic-lts-utopic*
  linux-image-3.16.0-30-generic* linux-image-3.16.0-46-generic*
  linux-image-extra-3.16.0-30-generic* linux-image-extra-3.16.0-46-generic*
  linux-image-generic-lts-utopic*
0 opgraderes, 0 nyinstalleres, 11 afinstalleres og 0 opgraderes ikke.
Efter denne handling, vil 559 MB diskplads blive frigjort.
Vil du fortsætte? [J/n]
</pre>

<h1>Tilføje repositories</h1>

<h2>Ved hjælp af <span class="inl_cmd">sources.list</span></h2>

<p>Da ubuntu blev installeret blev <span class="inl_cmd">/etc/apt/sources.list</span> konfigureret med standard repositories. Det betyder bl.a. at "partner" repositoriet er deaktiveret. I dette reposiory ligger der proporitære og closed-source programmer som kan være praktiske at få adgang til. Det skal vi have ændret. Åbn <span class="inl_cmd">/etc/apt/sources.list</span> med <span class="inl_cmd">nano</span> gå ned i bunden af filen:</p>

<code class="cmd">nano /etc/apt/sources.list</code>

<pre class="black">
<span class="blue1">## Uncomment the following two lines to add software from Canonical's
## 'partner' repository.
## This software is not part of Ubuntu, but is offered by Canonical and the
## respective vendors as a service to Ubuntu users.
# deb http://archive.canonical.com/ubuntu trusty partner <span class="red">&lt;-- denne linie skal ændres</span>
# deb-src http://archive.canonical.com/ubuntu trusty partner <span class="red">&lt;-- denne linie skal ændres</span>

## This software is not part of Ubuntu, but is offered by third-party
## developers who want to ship their latest software.</span>
<span class="brown">deb</span> <span class="green1">http://extras.ubuntu.com/ubuntu</span> <span class="red">trusty</span> <span class="violet">main</span>
<span class="brown">deb-src</span> <span class="green1">http://extras.ubuntu.com/ubuntu</span> <span class="red">trusty</span> <span class="violet">main</span>
</pre>

<p>Fjern <span class="inl_cmd">#</span> foran linierne så de kommer til at se ud som herunder:</p>

<pre class="black">
<span class="brown">deb</span> <span class="green1">http://archive.canonical.com/ubuntu</span> <span class="red">trusty</span> <span class="violet">partner</span>
<span class="brown">deb-src</span> <span class="green1">http://archive.canonical.com/ubuntu</span> <span class="red">trusty</span> <span class="violet">partner</span>
</pre>

<p>Opdater <span class="inl_cmd">apt</span>, så man fremover har adgang til programmer herfra.</p>

<code class="cmd">sudo apt-get update</code>

<h2>Ved hjælp af PPA</h2>

<p>Der findes en række repositories som er generelle for Ubuntu og Debian distributioner, og som bliver vedligeholdt til at tjene specifikke distributioner. Det hænder dog at man gerne vil have andre versioner af programmerne end disse repositories tilbyder. Dette bliver løst ved hjælp af PPA'er (<span class="bold">P</span>ersonal <span class="bold">P</span>ackage <span class="bold">A</span>archives).</p>

<p>Man skal dog være klar over at man ved at tilføje PPA'er tilføjer funktionalitet til sin distribution, og derved ofte installerer nyere version af programmer og afhængigheder udviklerne af distributionen har sagt god for. Derfor er det vigtigt at man kun anvender anerkendte PPA. Specielt når man anvender LTS systemer, vil der i løbet af 2 år komme opdateringer til programmer, som kan være nødvendige for ens workflow</p>

<p>Nedestående kommando tilføjer PPA linien og sikkerhedsnøgler til systemet.</p>

<code class="cmd">add-apt-repository PPA:[PPA navn] -y</code>

<p>Hvis man f.eks. ønsker at have den nyeste version af GIMP'en installeret anvender man PPA'en : <span class="inl_cmd">ppa:otto-kesselgulasch/gimp</span>. Den aktiveres med følgende kommando:</p>

<code class="cmd">add-apt-repository ppa:otto-kesselgulasch/gimp -y</code>

<p>Herefter vil commandoen oprette to nye filer i mappen <span class="inl_cmd">/etc/apt/sources.list.d</span>, så <span class="inl_cmd">apt</span> fremover kigger i dette arkiv også.</p>

<pre class="ubuntu_terminal">
thoj@thoj:/$ ls -a /etc/apt/sources.list.d | grep otto
<span class="red">otto</span>-kesselgulasch-gimp-trusty.list
<span class="red">otto</span>-kesselgulasch-gimp-trusty.list.save
</pre>

<p>Hvis programmet indeholder afhængigheder til nyere versioner af programmer der er installeret på computeren skal man udføre en <span class="inl_cmd">dist-upgrade</span>, f.eks:</p>

<code class="cmd">apt-get dist-upgrade -y</code>

<p>Nogle gange giver en <span class="inl_cmd">apt-get upgrade</span> Besked om at nogle pakker er blevet holdt tilbage efter en PPA opdatering (se rød markering).</p>

<pre class="ubuntu_terminal">
thoj@thoj-VirtualBox:~$ sudo apt-get upgrade
Indlæser pakkelisterne... Færdig
Opbygger afhængighedstræ        
Læser tilstandsoplysninger... Færdig
Beregner opgraderingen ... Færdig
<span class="red">Følgende pakker er blevet holdt tilbage:</span>
  linux-generic-lts-utopic linux-headers-generic-lts-utopic
  linux-image-generic-lts-utopic
0 opgraderes, 0 nyinstalleres, 0 afinstalleres og 3 opgraderes ikke.
</pre>

<p>Det skyldes, at de nye versioner der skal installeres kræver nyere filer end dem der er installeret. Dem skal du opdatere og det gøres ved at sætte <span class="inl_cmd">apt</span> til at lave en <span class="inl_cmd">dist-upgrade</span></p>

<code class="cmd">sudo apt-get dist-upgrade</code>

<h1>Harddiske og partitioner</h1>

<p>Linuxsystemet administrerer sine diske ved hjælp af den fysiske placering på bundkortet. Vores testsystem vil altså give følgende opdeling</p>

<table class="">
	<thead>
		<tr>
			<th>Fysiske placering</th>
			<th>Enhed</th>
			<th>Filplacering</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>SATA 1</td>
			<td>Harddisk 100GB</td>
			<td><span class="inl_cmd">/dev/sda</span></td>
		</tr>
		<tr>
			<td>SATA 2</td>
			<td>Harddisk 100GB</td>
			<td><span class="inl_cmd">/dev/sdb</span></td>
		</tr>
		<tr>
			<td>SATA 3</td>
			<td>DVD-drev</td>
			<td><span class="inl_cmd">/dev/sr0</span></td>
		</tr>
	</tbody>
</table>

<p>Når Linux starter op registrerer det alle fysisk tilsluttede enheder og sætter dem ind i sit filsystem på ovenstående adresser. Vi kan se hvordan systemets harddiske er sat op ved hjælp af <span class="inl_cmd">lsblk</span> og nogle options. Kommandoen skal køres som superuser, da nogle af informationerne kræver <span class="inl_cmd">root</span>-rettigheder </p>

<code class="cmd">sudo lsblk -o name,type,fstype,size,ro,type,mountpoint</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo lsblk -o name,type,fstype,size,ro,type,mountpoint
NAME   TYPE FSTYPE   SIZE RO TYPE MOUNTPOINT
sda    disk          100G  0 disk 
├─sda1 part ext4    46,6G  0 part /
├─sda2 part swap     3,8G  0 part [SWAP]
└─sda3 part ext4    28,9G  0 part /data
sdb    disk          100G  0 disk 
sr0    rom          1024M  0 rom  
</pre>

<p>Hvis vi kigger på harddisk <span class="inl_cmd">sda</span>, kan vi se at den er delt ind i 3 partitioner, der hver har sit monteringspunkt, hvorimod <span class="inl_cmd">sdb</span> hverken er partitioneret eller monteret.</p>

<h2>Hvad er en harddisk</h2>

<p>I daglig tale er harddisken den lille metalkasse der indeholder en til flere skiver, hvorpå der kan gemmes data. I computerteknologisk sammenhæng er det dog noget andet vi tænker på når vi kalder noget en harddisk.</p>

<p>En harddisk er en enhed der holder på data også selvom der ikke er strøm og derudover skal den indeholde en partitionstabel. Det betyder at følgende enheder vil blive opfattet som harddiske af Linux:</p>

<table class="">
	<thead>
		<tr>
			<th>Betegnelse</th>
			<th>Forklaring</th>
			<th>Montering</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>HDD</td>
			<td><span class="bold">H</span>ard <span class="bold">D</span>isk <span class="bold">D</span>rive</td>
			<td>Internt</td>
		</tr>
		<tr>
			<td>SSD</td>
			<td><span class="bold">S</span>olid <span class="bold">S</span>tate <span class="bold">D</span>rive</td>
			<td>Intern</td>
		</tr>
		<tr>
			<td>HHD</td>
			<td><span class="bold">H</span>ybrid <span class="bold">H</span>ard <span class="bold">D</span>rive</td>
			<td>Intern</td>
		</tr>
		<tr>
			<td>mSATA</td>
			<td><span class="bold">m</span>ini <span class="bold">S</span>erial <span class="bold">AT</span> <span class="bold">A</span>ttachment</td>
			<td>Intern</td>
		</tr>
		<tr>
			<td>eSATA</td>
			<td><span class="bold">e</span>xternal <span class="bold">S</span>erial <span class="bold">AT</span> <span class="bold">A</span>ttachment</td>
			<td>Ekstern</td>
		</tr>
		<tr>
			<td>USB</td>
			<td><span class="bold">U</span>niversal <span class="bold">S</span>erial <span class="bold">B</span>us</td>
			<td>Ekstern</td>
		</tr>
	</tbody>
</table>

<p>Linux kan starte fra alle partitioner, da selve bootprocessen styres af en bootmanager.</p>

<h2>Harddiskens opsætning</h2>

<p><span class="inl_cmd">lsblk</span> viser hvad operativsystemet kan se. Hvis vi ønsker at kigge på selve harddisken skal vi anvende programmet <span class="inl_cmd">fdisk</span>. Dette program konfigurerer selve harddisken og hvordan den er inddelt. Af samme årsag skal <span class="inl_cmd">fdisk</span> altid køres som <span class="inl_cmd">root</span>. Vi kan heller ikke se med hvilket filsystem drevet er formateret, kun hvilken type det er forberedt til.</p>

<code class="cmd">sudo fdisk -l</code>

<p>Jeg har i nedestående kode markeret hvor informationerne om henholdsvis <span class="inl_cmd">sda</span> og <span class="inl_cmd">sdb</span> starter. Læg mærke til at <span class="inl_cmd">fdisk</span> ikke har registreret DVD-drevet, da det ikke er et fast drev.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo fdisk -l

<span class="red">Disk /dev/sda: 107.4 GB, 107374182400 bytes</span>
255 hoveder, 63 sektorer/spor, 13054 cylindre, i alt 209715200 sektorer
Enheder = sektorer af 1 * 512 = 512 byte
Sektorstørrelse (logisk/fysisk): 512 byte / 512 byte
I/O-størrelse (minimum/optimal): 512 byte / 512 byte
Diskidentifikation: 0x00031198

    Enhed Opstart   Start         Slut     Blokke   Id  System
/dev/sda1   *        2048    97656831    48827392   83  Linux
/dev/sda2        97656832   105656319     3999744   82  Linux swap / Solaris
/dev/sda3       105656320   166203391    30273536   83  Linux

<span class="red">Disk /dev/sdb: 107.4 GB, 107374182400 bytes</span>
255 hoveder, 63 sektorer/spor, 13054 cylindre, i alt 209715200 sektorer
Enheder = sektorer af 1 * 512 = 512 byte
Sektorstørrelse (logisk/fysisk): 512 byte / 512 byte
I/O-størrelse (minimum/optimal): 512 byte / 512 byte
Diskidentifikation: 0x00000000

Disk /dev/sdb indeholder ikke en gyldig partitionstabel
</pre>

<p><span class="inl_cmd">sda</span> blliver gjort tilgængelig for Linux ved hjælp af filen <span class="inl_cmd">/etc/fstab</span>. Vi kan kigge på filen ved hjælp af <span class="inl_cmd">nano</span>. Gem kun ændringer hvis du er helt sikker på hvad du gør, da Linux måske ikke kan montere harddiskene ved genstart.</p>

<pre class="black">
# /etc/fstab: static file system information.
#
# Use 'blkid' to print the universally unique identifier for a
# device; this may be used with UUID= as a more robust way to name devices
# that works even if disks are added and removed. See fstab(5).
#
# &lt;file system&gt; &lt;mount point&gt;  &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
# / was on /dev/sda1 during installation
UUID=c2c76ea3-8bee-4930-be2c-20d11a7358c1 /               ext4    errors=remount-ro 0       1
# /data was on /dev/sda3 during installation
UUID=a2d7f466-6131-4048-86b1-b0304e9bd905 /data           ext4    defaults        0       2
# swap was on /dev/sda2 during installation
UUID=1c538622-36c6-4fcb-a127-636a82ad84e3 none            swap    sw              0       0

</pre>

<h2>Opsætning af harddisk</h2>

<p>I dette eksempel har vi en 100GB harddisk der endnu ikke er tilføjet til vores filsystem. Når en harddisk skal sættes op skal den:</p>

<ol class="">
	<li>Identificeres (Placering)</li>
	<li>Sættes op (Partitioneres)</li>
	<li>Formateres (Formateres)</li>
</ol>

<h3>Identifikation af harddiskens placering</h3>

<p>For at identificere harddisken køres kommandoen <span class="inl_cmd">lsblk</span> (se ovenfor). I dette tilfælde <span class="inl_cmd">sdb</span>.</p>

<h3>Partitionering af harddisken</h3>

<p>Harddiske partitioneres af programmet <span class="inl_cmd">fdisk</span>, så længe de er under 2 TB. Er det over 2 TB anvendes programmet gdisk, som ikke bliver gennemgået her. Start partitioneringsprogrammet op med med:</p>

<p><span class="bold">VIGTIGT</span>: Hvis du på noget tidspunkt bliver i tvivl om at du har gjort noget forkert, så kan du hoppe ud af programmet ved at bruge <kbd>q</kbd> eller <kbd>Ctrl</kbd>+<kbd>c</kbd>! Programmet skriver først til disken når du vælger det.</p>

<code class="cmd">sudo fdisk /dev/sdb</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo fdisk /dev/sdb
[sudo] password for tj: 
Enheden indeholder hverken en gyldig DOS-partitionstabel eller en Sun-, SGI- eller OSF-disketiket.
Opretter en ny DOS-disketiket med diskidentifikation 0xfad2f3ee.
Ændringer vil holdes i hukommelsen, indtil du bestemmer dig for at
gemme dem. Derefter kan det tidligere indhold naturligvis ikke genskabes.

Advarsel: Ugyldigt flag 0x0000 for partitionstabel 4 vil blive rettet med »w« (forkortelse for write; dansk=skriv)

Kommando (m for hjælp): 
</pre>

<p>Det første <span class="inl_cmd">fdisk</span> gør, er at gøre opmærksom på at disken ikke har nogen partitionstabel. Det er det første der skal oprettes. Tast <kbd>m</kbd> og så <kbd>Enter</kbd>:</p>

<pre class="black">
Kommando (m for hjælp): <kbd>m</kbd>+<kbd>Enter</kbd>
Kommandobeskrivelse
   a   skift et opstartsflag (bootable)
   b   skift bsd-disketiket
   c   skift DOS-kompatilitetsflaget
   d   slet en partition
   l   vis liste over kendte partitionstyper
   m   vis denne menu
   n   tilføj en ny partition
   o   opret en ny, tom DOS-partitionstabel
   p   vis partitionstabellen
   q   afslut uden at gemme ændringerne
   s   opret en ny, tom Sun-disketiket
   t   skift system-id for en partition
   u   skift enheder for visning/indtastning
   v   verificer partitionstabellen
   w   skriv partitionstabel til disk og afslut
   x   ekstra funktionalitet (kun for eksperter)

Kommando (m for hjælp): 
</pre>

<p>Først skal der oprettes en ny partitionstabel. Tryk <kbd>o</kbd></p>

<pre class="black">
Kommando (m for hjælp): <kbd>o</kbd>+<kbd>Enter</kbd>
Opretter en ny DOS-disketiket med diskidentifikation 0xa6162a16.
Ændringer vil holdes i hukommelsen, indtil du bestemmer dig for at
gemme dem. Derefter kan det tidligere indhold naturligvis ikke genskabes.

Advarsel: Ugyldigt flag 0x0000 for partitionstabel 4 vil blive rettet med »w« (forkortelse for write; dansk=skriv)

Kommando (m for hjælp):
</pre>

<p>Herefter skal der oprettes en ny partition. Det er en proces med flere tastetryk, som jeg viser samlet herunder. Det du skal taste er:</p>

<ol class="">
	<li>[n] - opret ny partition</li>
	<li>[p] - den skal være primær</li>
	<li>[Enter] - vælg første partition (standard)</li>
	<li>[Enter] - vælg første sektor (standard)</li>
	<li>[Enter] - vælg sidste sektor (standard)</li>
</ol>

<p></p>

<pre class="black">
Kommando (m for hjælp): <kbd>n</kbd>+<kbd>Enter</kbd>
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): <kbd>p</kbd>+<kbd>Enter</kbd>
Partitionsnummer (1-4, standard 1): <kbd>Enter</kbd>
Bruger standardværdi 1
Første sektor (2048-209715199, standard 2048): <kbd>Enter</kbd>
Bruger standardværdi 2048
Seneste sektor, +sektorer eller +størrelse{K,M,G} (2048-209715199, standard 209715199): <kbd>Enter</kbd>
Bruger standardværdi 209715199

Kommando (m for hjælp): 
</pre>

<p>Få en oversigt over det du har gjort: tast <kbd>p</kbd></p>

<pre class="black">
Kommando (m for hjælp): <kbd>p</kbd>+<kbd>Enter</kbd>

Disk /dev/sdb: 107.4 GB, 107374182400 bytes
255 hoveder, 63 sektorer/spor, 13054 cylindre, i alt 209715200 sektorer
Enheder = sektorer af 1 * 512 = 512 byte
Sektorstørrelse (logisk/fysisk): 512 byte / 512 byte
I/O-størrelse (minimum/optimal): 512 byte / 512 byte
Diskidentifikation: 0xa6162a16

    Enhed Opstart   Start         Slut     Blokke   Id  System
/dev/sdb1            2048   209715199   104856576   83  Linux

Kommando (m for hjælp): 
</pre>

<p>Vær opmærksom på <span class="inl_cmd">Id</span> og <span class="inl_cmd">System</span>. Det angiver hvilke typer af filsystemer partitionen kan formateres til. Her er det korrekt at det skal være <span class="inl_cmd">83</span> og <span class="inl_cmd">Linux</span>.</p>

<p>Skriv ændringerne til disken. Tast <kbd>w</kbd></p>

<pre class="black">
Kommando (m for hjælp): <kbd>w</kbd>+<kbd>Enter</kbd>
Partitionstabellen er ændret!

Kalder ioctl() for at genindlæse partitionstabellen.
Synkroniserer diske.
tj@tj-VirtualBox:~$ 
</pre>

<p>Før vi går videre tjekker vi om disken er partitioneret korrekt med: <span class="inl_cmd">fdisk -l /dev/sdb</span></p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo fdisk -l /dev/sdb

Disk /dev/sdb: 107.4 GB, 107374182400 bytes
43 hoveder, 44 sektorer/spor, 110843 cylindre, i alt 209715200 sektorer
Enheder = sektorer af 1 * 512 = 512 byte
Sektorstørrelse (logisk/fysisk): 512 byte / 512 byte
I/O-størrelse (minimum/optimal): 512 byte / 512 byte
Diskidentifikation: 0xa6162a16

    Enhed Opstart   Start         Slut     Blokke   Id  System
/dev/sdb1            2048   209715199   104856576   83  Linux
</pre>

<h3>Formater harddisken</h3>

<p>Harddisken skal fomateres til <span class="inl_cmd">ext4</span>. Det gøres med kommandoen:</p>

<code class="cmd">sudo mkfs -t ext4 /dev/sdb1</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo mkfs -t ext4 /dev/sdb1
mke2fs 1.42.9 (4-Feb-2014)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
6553600 inodes, 26214144 blocks
1310707 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=4294967296
800 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 
	4096000, 7962624, 11239424, 20480000, 23887872

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done   

tj@tj-VirtualBox:~$
</pre>

<p>Vi tjekker om harddisken er formateret korrekt med <span class="inl_cmd">lsblk</span> (min markering).</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo lsblk -o name,type,fstype,size,ro,type,mountpoint
NAME   TYPE FSTYPE   SIZE RO TYPE MOUNTPOINT
sda    disk          100G  0 disk 
├─sda1 part ext4    46,6G  0 part /
├─sda2 part swap     3,8G  0 part [SWAP]
└─sda3 part ext4    28,9G  0 part /data
sdb    disk          100G  0 disk 
└─<span class="red">sdb1 part ext4     100G  0 part </span>
sr0    rom          1024M  0 rom
</pre>

<h2>Montering af harddiske</h2>

<p>Som vi har gennemgået ovenfor, så er der to mapper i filstrukturen til at montere drev i. Det er henholdsvis <span class="inl_cmd">/mnt</span> og <span class="inl_cmd">/media</span>. Vi vil i denne sammenhæng vælge <span class="inl_cmd">/media</span> da det handler om en harddisk.</p>

<p>Vi vil herunder gennemgå en midlertidig montering, som hvis det havde været et eSATA/USB-drev, og en fast montering i filstrukturen.</p>

<h3>Midlertidig montering af harddisken</h3>

<p>Arbejdsgangen når man monterer en disk er følgende:</p>

<ol class="">
	<li>Oprette en mappe til at montere drevet i.</li>
	<li>Monteres på filsystemet (Montering)</li>
	<li>Konfigureres (Rettigheder)</li>
</ol>

<p>Opret mappe til at montere drevet i. Her vælger vi <span class="inl_cmd">/media/backup</span>.</p>

<code class="cmd">sudo mkdir /media/backup</code>

<p>Drevet monteres:</p>

<code class="cmd">sudo mount /dev/sdb1 /media/backup</code>

<p>Kontroller at harddisken er monteret med <span class="inl_cmd">lsblk</span>.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0   100G  0 disk 
├─sda1   8:1    0  46,6G  0 part /
├─sda2   8:2    0   3,8G  0 part [SWAP]
└─sda3   8:3    0  28,9G  0 part /data
sdb      8:16   0   100G  0 disk 
└─<span class="red">sdb1   8:17   0   100G  0 part /media/backup</span>
sr0     11:0    1  1024M  0 rom  
</pre>

<p>Kontroller rettighederne</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo ls -al /media | grep backup
drwxr-xr-x   3 root root 4096 mar 16 15:00 <span class="red">backup</span>
</pre>

<p>Ændre ejerskabet og rettighederne så kun du har adgang til drevet</p>

<code class="cmd">sudo chown -R tj:tj /media/backup</code>

<code class="more_cmd">sudo chmod -R 700 /media/backup/</code>

<p>Kontroller rettighederne igen</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo ls -al /media | grep backup
drwx------   3 tj   tj   4096 mar 16 15:00 <span class="red">backup</span>
</pre>

<p>Afmonter herefter drevet igen, for at vi kan montere det fast ved hjælp af <span class="inl_cmd">/etc/fstab</span>.</p>

<code class="cmd">umount /dev/sdb1</code>

<h3>Fast montering i filsystemet</h3>

<p>Arbejdsgangen når man monterer en disk er følgende:</p>

<ol class="">
	<li>Oprette en mappe til at montere drevet i.</li>
	<li>Find diskens UUID (<span class="bold">U</span>niversally <span class="bold">U</span>nique <span class="bold">ID</span>entifier)</li>
	<li>Monteres på filsystemet (Montering)</li>
	<li>Konfigureres (Rettigheder)</li>
</ol>

<p>Her vil vi montere drevet i mappen <span class="inl_cmd">/backup</span>. Opret mappen:</p>

<code class="cmd">mkdir /backup</code>

<p>Find diskens UUID</p>

<code class="cmd">sudo blkid /dev/sdb1</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:/media$ sudo blkid /dev/sdb1
/dev/sdb1: UUID="6731e565-b3d7-4d81-86c7-74b6e3e1d591" TYPE="ext4" 
</pre>

<p>Det lange UUID nummer (6731e565-b3d7-4d81-86c7-74b6e3e1d591) er et tilfældigt nummer som Ubuntu har skabt og består af en 128bits kode. Det er en sikkerhedsfaktor der gør, at man ikke bare kan skifte en disk ud, uden at Ubuntu opdager det. Du skal selvfølgelig anvende den UUID dit system angiver. Åben filen <span class="inl_cmd">/etc/fstab</span> med nano og indsæt det med rødt (med din UUID):</p>

<code class="cmd">sudo nano /etc/fstab</code>

<pre class="black">
# /etc/fstab: static file system information.
#
# Use 'blkid' to print the universally unique identifier for a
# device; this may be used with UUID= as a more robust way to name devices
# that works even if disks are added and removed. See fstab(5).
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
# / was on /dev/sda1 during installation
UUID=c2c76ea3-8bee-4930-be2c-20d11a7358c1 /               ext4    errors=remount-ro 0       1
# /data was on /dev/sda3 during installation
UUID=a2d7f466-6131-4048-86b1-b0304e9bd905 /data           ext4    defaults        0       2
# swap was on /dev/sda2 during installation
UUID=1c538622-36c6-4fcb-a127-636a82ad84e3 none            swap    sw              0       0

<span class="red">#Tilføjet /dev/sdb1 som backup drev
UUID=6731e565-b3d7-4d81-86c7-74b6e3e1d591 /backup ext4 defaults 0 2</span>
</pre>

<p>Monter alle drev fra <span class="inl_cmd">/etc/fstab</span>:</p>

<code class="cmd">sudo mount -a</code>

<p>Tjek at drevet er monteret med <span class="inl_cmd">lsblk</span>.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0   100G  0 disk 
├─sda1   8:1    0  46,6G  0 part /
├─sda2   8:2    0   3,8G  0 part [SWAP]
└─sda3   8:3    0  28,9G  0 part /data
sdb      8:16   0   100G  0 disk 
└─<span class="red">sdb1   8:17   0   100G  0 part /backup</span>
sr0     11:0    1  1024M  0 rom 
</pre>

<p>Herefter vil drevet være monteret ved hver opstart.</p>

<p>Ændre ejerskabet og rettighederne så kun du har adgang til drevet</p>

<code class="cmd">sudo chown -R tj:tj /media/backup</code>

<code class="more_cmd">sudo chmod -R 700 /media/backup/</code>

<p>Denne metode kan anvendes både til alle former for harddiske og netværksdrev.</p>


<p><a href="https://help.ubuntu.com/community/InstallingANewHardDrive" target="_blank">https://help.ubuntu.com/community/InstallingANewHardDrive</a></p>


<h2>Lave USB-boot disk</h2>

<p>Ofte har man brug for at lave en nøjagtig kopi af en partition, f.eks. når man skal brænde en ISO fil over på en USB disk. Dette gøres med programmet <span class="inl_cmd">dd</span>. Der findes også GUI programmer til det, men min erfaring er, at de nogle gange roder med partitionstabellen, så drevet USB disken reelt bliver ubrugelig. <span class="inl_cmd">dd</span> virker altid!</p> 

<code class="cmd">dd if=*input fil* of=*destinations fil* *Optioner*</code>
<code class="more_cmd">sync</code>

<p><span class="bold">VIGTIGT</span>: Det er vigtigt at køre sync efter man har kopieret data, da man risikerer at ikke al data er skrevet. Det skyldes at mange filskrivningsoperationerer cached, så operativsystemet kan vente med at skrive til det har tid.</p>

<p>Herunder er vist hele proceduren med at oprette en USB bootdisk fra en ISO.</p>

<ol class="">
	<li>Kør <span class="inl_cmd">isohybrid</span> på isofilen</li>
	
		<code class="cmd">isohybrid *isofil*</code>
		
	<li>Sæt USB-nøglen i, og vent til systemet har initialiseret den (ca. 5 sekunder)</li>
	
	<li>Afmonter USB nøglen</li>
	
		<code class="cmd">umount *sti_til_USB*</code>
	
	<li>kør dd </li>
	
		<code class="cmd">dd if=*sti_til_filen* of=*sti_til_USB*</code>
		
	<li><span class="red">*VIGTIGT*</span> Kør <span class="inl_cmd">sync</span>, for at sikr dig at alle data er skrevet til USB disken </li>
</ol>

<p>På systemet vi her går ud fra er der i forvejen to harddiske, hvilket betyder at en USB-disk vil blive registreret som den efterfølgende, altså <span class="inl_cmd">/dev/sdc</span>.</p>

<p>I eksemplet herunder oprettes en USB-bootdisk med systemrescueCD. En distribution jeg varmt kan anbefale til systemarbejde. ISO filen er blevet hentet på nettet (<a href="https://www.system-rescue-cd.org/Download" target="_blank">https://www.system-rescue-cd.org/Download</a>) og placeret her <span class="inl_cmd">/data/systemrescuecd-x86-4.7.1.iso</span>.</p>

<p>Find ISO-filens placering og navn.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ls -al /data | grep *.iso
-rw-rw-r--  1 thoj thoj 481296384 feb 25 11:40 <span class="red">systemrescuecd-x86-4.7.1.iso</span>
tj@tj-VirtualBox:~$ sudo isohybrid /data/systemrescuecd-x86-4.7.1.iso 
</pre>

<p>USB-disken sættes i (vent 5 sekunder), afmonter disken og tjek at den er afmonteret</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ lsblk | grep sdc
<span class="red">sdc</span>      8:16   1   3,8G  0 disk 
└─<span class="red">sdc</span>1   8:17   1   3,8G  0 part /media/tj/663A-63FE
tj@tj-VirtualBox:~$ sudo umount /dev/sdb1
tj@tj-VirtualBox:~$ sudo lsblk | grep sdb
<span class="red">sdc</span>      8:16   1   3,8G  0 disk 
└─<span class="red">sdc</span>1   8:17   1   3,8G  0 part
</pre>

<p>Kopier ISO filen over på USB-nøglen (Det tager et par minutter alt efter størrelsen på isofilen) og kør <span class="inl_cmd">sync</span></p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo dd if=/data/systemrescuecd-x86-4.7.1.iso of=/dev/sdb
[sudo] password for thoj: 
940032+0 blokke ind
940032+0 blokke ud
481296384 byte (481 MB) kopieret, 130,186 s, 3,7 MB/s
tj@tj-VirtualBox:~$ sync
tj@tj-VirtualBox:~$
</pre>

<p>Herefter kan USB-drevet fjernes og anvendes til at boote med.</p>


<p>Læs også: <a href="https://www.system-rescue-cd.org/Sysresccd-manual-en_How_to_install_SystemRescueCd_on_an_USB-stick" target="_blank">https://www.system-rescue-cd.org/Sysresccd-manual-en_How_to_install_SystemRescueCd_on_an_USB-stick</a></p>

<p>Læs også: <a href="https://wiki.archlinux.org/index.php/disk_cloning" target="_blank">https://wiki.archlinux.org/index.php/disk_cloning</a></p>

<p>man-page <span class="inl_cmd">dd</span>: 
	<a href="http://manpages.ubuntu.com/manpages/trusty/man1/dd.1.html" target="_blank">
	http://manpages.ubuntu.com/manpages/trusty/man1/dd.1.html</a></p>



<h1>Netværks værktøjer</h1>

<p>I dette kapitel vil det blive vist hvordan man kan analysere sit netværk.</p>

<h2><span class="inl_cmd">ifconfig</span></h2>

<p><span class="inl_cmd">ifconfig</span> anvendes til at vise netværkskonfigurationen, men kan også anvendes til at konfigurere netværkskort. Herunder er kommandoen blevet kørt "ren".</p>

<code class="cmd">ifconfig</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ifconfig
eth0      Link encap:Ethernet  HWaddr 08:00:27:99:37:e3  
<span class="red">          inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0</span>
          inet6 addr: fe80::a00:27ff:fe99:37e3/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:825 errors:0 dropped:0 overruns:0 frame:0
          TX packets:663 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:418700 (418.7 KB)  TX bytes:52990 (52.9 KB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:208 errors:0 dropped:0 overruns:0 frame:0
          TX packets:208 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:18230 (18.2 KB)  TX bytes:18230 (18.2 KB)

</pre>

<p>Her kan vi se der er to netværkskort: <span class="inl_cmd">eth0</span> og <span class="inl_cmd">io</span>. Hvis du kører Ubuntu på en bærbar med WiFi hedder den første <span class="inl_cmd">wlan0</span>. Den linie du især skal lægge mærke til er den jeg har markeret med rødt. Den linie fortæller alt hvad din computer har brug for, for at kunne identificeres korrekt på nettet.</p>

<h2><span class="inl_cmd">ping</span></h2>

<p><span class="inl_cmd">ping</span> bruges til at undersøge om der er forbindelse mellem din og en anden computer, og hvor lang svartiden er. Kommandoen kører lige til der trykkes <kbd>Ctrl</kbd>+<kbd>c</kbd>.</p>

<code class="cmd">ping dr.dk</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ping dr.dk
PING dr.dk (159.20.6.38) 56(84) bytes of data.
64 bytes from 159.20.6.38: icmp_seq=1 ttl=63 time=12.8 ms
64 bytes from 159.20.6.38: icmp_seq=2 ttl=63 time=111 ms
64 bytes from 159.20.6.38: icmp_seq=3 ttl=63 time=13.1 ms
64 bytes from 159.20.6.38: icmp_seq=4 ttl=63 time=13.6 ms
64 bytes from 159.20.6.38: icmp_seq=5 ttl=63 time=14.1 ms
^C
--- dr.dk ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4006ms
rtt min/avg/max/mdev = 12.842/33.051/111.476/39.215 ms
</pre>

<p>Efter kommandoen er kørt vises en opsumering</p>

<p>Andre eksempler med ping kommandoen:</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>ping -c 4 dr.dk</td>
			<td>Kører ping i alt 4 gange</td>
		</tr>
		<tr>
			<td>ping -i 2 dr.dk</td>
			<td>der pinges med 2 sekunders mellemrum</td>
		</tr>
		<tr>
			<td>ping -s 504 dr.dk</td>
			<td>Der pinges med 512 (504+8) bytes i stedet for 64. Der skal angives 8 mindre end man ønsker, da 8 bytes bliver tilføjet (header data) </td>
		</tr>
	</tbody>
</table>


<p>man-page: <span class="inl_cmd">ping</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man8/ping.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man8/ping.8.html</a></p>

<h2>Find din DNS-server</h2>

<p>DNS serveren sørger for at man kan anvende navne på nettet i stedeet for IP-adresser. For at finde den DNS computeren er tilstluttet anvendes følgende kommando: </p>

<code class="cmd">nmcli dev list iface *netværkskort* | grep IP4</code>

<p>Du kan se fra <span class="inl_cmd">ifconfig</span> kommandoen hvad der skal stå i stedet for *netværkskort*. I mit tilfælde <span class="inl_cmd">eth0</span>. DNS serveren er den der heder <span class="inl_cmd">IP4.DNS[1]</span>.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ sudo nmcli dev list iface eth0 | grep IP4
[sudo] password for tj: 
<span class="red">IP4</span>.ADRESSE[1]:                         ip = 10.0.2.15/24, gw = 10.0.2.2
<span class="red">IP4</span>.DNS[1]:                             10.0.2.3
</pre>

<p>Et <span class="inl_cmd">nslookup</span> på denne adresse giver følgende:</p>

<code class="cmd">nslookup 10.0.2.3</code>


<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ nslookup 10.0.2.3
Server:		127.0.1.1
Address:	127.0.1.1#53

** server can't find 3.2.0.10.in-addr.arpa: NXDOMAIN
</pre>

<p>Det ovenstående output et meget minimalistisk. Det skyldes at Virtualbox kun har en meget minimalistisk DNS tjeneste kørende. Modsat mit rigtige system, der tager fat i Yousee's DNS servere. De samme opslag på min computer giver følgende:</p>

<pre class="ubuntu_terminal">
thoj@thoj-Precision-M4800:~$ nmcli dev list iface wlan0 | grep IP4
<span class="red">IP4</span>.ADRESSE[1]:                         ip = 192.168.0.56/24, gw = 192.168.0.1
<span class="red">IP4</span>.DNS[1]:                             193.162.153.164
<span class="red">IP4</span>.DNS[2]:                             194.239.134.83
thoj@thoj-Precision-M4800:~$ nslookup 192.162.153.164
Server:		127.0.1.1
Address:	127.0.1.1#53

Non-authoritative answer:
164.153.162.192.in-addr.arpa	name = ip-192-162-153-164.cyberlan.com.ua.

Authoritative answers can be found from:
153.162.192.in-addr.arpa	nameserver = ns1.cyberlan.com.ua.
153.162.192.in-addr.arpa	nameserver = ns2.syndicate.net.ua.
</pre>

<p>man-page: <span class="inl_cmd">nslookup</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man1/nslookup.1.html" target="_blank">http://manpages.ubuntu.com/manpages/trusty/en/man1/nslookup.1.html</a></p>


<h2><span class="inl_cmd">mtr</span></h2>

<p><span class="inl_cmd">mtr</span> er et program der kombinerer traceroute og ping, dvs. at det både viser hoppene mellem din computer og målcomputeren samtidig med at den viser tidsintervallerne. Installer det med følgende kommando:</p>

<p>Kommandoen er:</p>

<code class="cmd">mtr [--report] www.dr.dk</code>

<p>	Det er valgfrit at indsætte <span class="inl_cmd">--report</span> i kommandoen. --report venter med at lave et output til det har kørt 10 omgange. </p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ mtr --report dr.dk
Start: Sat Mar 19 00:23:28 2016
HOST: tj-VirtualBox               Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- 10.0.2.2                   0.0%    10    0.5   0.4   0.2   0.6   0.0
  2.|-- 192.168.0.1                0.0%    10    1.6   6.8   1.4  52.9  16.2
  3.|-- ???                       100.0    10    0.0   0.0   0.0   0.0   0.0
  4.|-- ae11-100.odttv1nqe10.dk.i  0.0%    10   13.1  20.9  10.3 108.4  30.7
  5.|-- ae1-0.alb2nqp7.dk.ip.tdc.  0.0%    10   34.3  23.0  11.2  56.2  14.1
  6.|-- 194.19.204.22              0.0%    10  103.1  37.5  13.4 103.1  38.2
  7.|-- 0xc213cf12.linknet.dk.tel  0.0%    10   14.4  15.3  13.6  17.6   0.9
  8.|-- 159.20.6.38                0.0%    10   77.4  27.8  12.1  77.4  21.6
</pre>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>mtr -n dr.dk</td>
			<td>Viser IP-adresserne på routen og ikke deres DNS-opløste navne</td>
		</tr>
		<tr>
			<td>mtr -c 4 --report dr.dk</td>
			<td>Kører kun fire gennemgange før der kommer output. Uden <span class="inl_cmd">-c</span> kører kommandoen 10 gange.</td>
		</tr>
	</tbody>
</table>

<p>man-page : <span class="inl_cmd">mtr</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man8/mtr.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man8/mtr.8.html</a></p>

<h2><span class="inl_cmd">nmap</span></h2>

<p><span class="inl_cmd">nmap</span> installeres med følgende kommandoen.</p>

<code class="cmd">apt-get install nmap -y</code>

<p><span class="inl_cmd">nmap</span> kan bruges til at scanne et netværk for åbne porte ved at angive IP adressen:</p>

<code class="cmd">nmap *IP-adresse*/*Internet_adresse*</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ nmap 10.0.2.15

Starting Nmap 6.40 ( http://nmap.org ) at 2016-03-19 00:36 CET
Nmap scan report for 10.0.2.15
Host is up (0.00012s latency).
All 1000 scanned ports on 10.0.2.15 are closed

Nmap done: 1 IP address (1 host up) scanned in 0.06 seconds

</pre>

<p><span class="inl_cmd">nmap</span> kan også anvendes til at scanne computere på nettet, her dr.dk</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ nmap dr.dk

Starting Nmap 6.40 ( http://nmap.org ) at 2016-03-19 00:37 CET
Nmap scan report for dr.dk (159.20.6.38)
Host is up (0.022s latency).
Not shown: 998 filtered ports
PORT    STATE SERVICE
80/tcp  open  http
443/tcp open  https

Nmap done: 1 IP address (1 host up) scanned in 7.48 seconds
</pre>

<p>Det viser at Danmarks Radio har sat deres server fornuftigt op, da den kun har to porte åben udadtil.</p>

<p>nmap kan også anvendes til følgende:</p>

<p>Scanne hele subnet (her <span class="inl_cmd">10.0.2.0/24)</span>:</p>

<code class="cmd">nmap 10.0.2.0/24</code>

<p>Scanne en del af et subnet (jer <span class="inl_cmd">10.0.2.10-50</span>):</p>

<code class="cmd">nmap 10.0.2.10-50</code>

<p>Nmap kan også anvendes til at finde alle aktive computere på et subnet med kommandoen:</p>

<code class="cmd">nmap 10.0.2.0/24 | grep "Nmap scan report"</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ nmap 10.0.2.0/24 | grep "Nmap scan report"
<span class="red">Nmap scan report</span> for 10.0.2.2
<span class="red">Nmap scan report</span> for 10.0.2.3
<span class="red">Nmap scan report</span> for 10.0.2.4
<span class="red">Nmap scan report</span> for 10.0.2.15
</pre>

<p>man-page: <span class="inl_cmd">nmap</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man1/nmap.1.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man1/nmap.1.html</a></p>

<h1>Computerens hardware</h1>

<h2><span class="inl_cmd">dmesg</span></h2>

<p><span class="inl_cmd">dmesg</span> er en kommando det giver et output af det som kernen har indlæst, og er meget omfattende. Findes på alle computere og er især anvendeligt hvis man samtidig anvender <span class="inl_cmd">grep</span>. </p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>dmesg</td>
			<td>Giver et komplet output af det kernen har indlæst</td>
		</tr>
		<tr>
			<td>dmesg | grep -i usb</td>
			<td>Find henvisninger til eth0 og ETH0 i dmesg udskriften. -i gør, at søgningen både bliver efter store og små bogstaver</td>
		</tr>
	</tbody>
</table>

<p>man-page: <span class="inl_cmd">dmesg</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man1/dmesg.1.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man1/dmesg.1.html</a></p>

<h2><span class="inl_cmd">dmidecode</span></h2>

<p>Dmidecode laver en udskrift af de beskrivelser som BIOS har om din hardware</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>dmidecode</td>
			<td>Laver en komplet udskrift af din hardware</td>
		</tr>
		<tr>
			<td>dmidecode -t 2</td>
			<td>Informationer om bundkortet. Der findes mange andre <span class="inl_cmd">-t</span> værdier (o-42) som kan findes på man siden.</td>
		</tr>
	</tbody>
</table>

<p>man-page: <span class="inl_cmd">dmidecode</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/man8/dmidecode.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man8/dmidecode.8.html</a></p>

<h2><span class="inl_cmd">inxi</span></h2>

<p>Giver dig informationer om computerens hardware på en læselig måde. Skal førest installeres:</p>

<code class="cmd">sudo apt-get install inxi</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ inxi
<span class="blue1">CPU</span>~Single core Intel Core i7-4600M CPU (-UP-) clocked at 2893.298 Mhz <span class="blue1">Kernel</span>~4.2.0-34-generic x86_64 <span class="blue1">Up</span>~1:45 <span class="blue1">Mem</span>~544.7/3952.5MB <span class="blue1">HDD</span>~214.7GB(2.3% used) <span class="blue1">Procs</span>~172 <span class="blue1">Client</span>~Shell <span class="blue1">inxi</span>~1.9.17  
</pre>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>inxi -b</td>
			<td>Giver en komprimeret oversigt over din hardware</td>
		</tr>
		<tr>
			<td>inxi -v 7</td>
			<td>Giver en oversigt over al din hardware og opsætning. Der kan anvendes værdier fra 0-7</td>
		</tr>
	</tbody>
</table>

<p>man-page: <span class="inl_cmd">inxi</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/man1/inxi.1.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man1/inxi.1.html</a></p>

<h2><span class="inl_cmd">uname</span></h2>

<p>Uname giver dig mulighed for at få informationer om systemet. F.eks:</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>uname -r</td>
			<td>Udskriver den version kernen har.</td>
		</tr>
		<tr>
			<td>uname -a</td>
			<td>Udskriv al information</td>
		</tr>
		<tr>
			<td>uname -m</td>
			<td>Viser om du kører 32 bit (i386, i586, i686) eller 64 bit (x86_64)</td>
		</tr>
	</tbody>
</table>

<p>man-page: <span class="inl_cmd">inxi</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man1/uname.1.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man1/uname.1.html</a></p>


<h2><span class="inl_cmd">lsblk</span> - <span class="inl_cmd">lshw</span> - <span class="inl_cmd">lspci</span> - <span class="inl_cmd">lsusb</span> - <span class="inl_cmd">lpinfo</span></h2>

<p>Viser detaljerede oplysninger om dit hardware.</p>

<table class="cmd_table">
	<thead>
		<tr>
			<th></th>
			<th></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>lsblk</td>
			<td>Informationer om diske på systemet. (gennemgået ovenfor)</td>
		</tr>
		<tr>
			<td>lshw</td>
			<td>Giver en detaljeret oversigt over  din hardware</td>
		</tr>
		<tr>
			<td>lspci</td>
			<td>Giver information om systemets PCI enheder</td>
		</tr>
		<tr>
			<td>lsusb</td>
			<td>Giver informationer om systemets usb enheder</td>
		</tr>
		<tr>
			<td>lpinfo</td>
			<td>Giver informationer om printere og printerdrivere på systemet.</td>
		</tr>
	</tbody>
</table>

<p>man-page: <span class="inl_cmd">lsblk</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/en/man8/lsblk.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/en/man8/lsblk.8.html</a></p>

<p>man-page: <span class="inl_cmd">lshw</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/man1/lshw.1.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man1/lshw.1.html</a></p>

<p>man-page: <span class="inl_cmd">lsusb</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/man8/lsusb.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man8/lsusb.8.html</a></p>

<p>man-page: <span class="inl_cmd">lspci</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/man8/lspci.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man8/lspci.8.html</a></p>

<p>man-page: <span class="inl_cmd">lpinfo</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/man8/lpinfo.8.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man8/lpinfo.8.html</a></p>

<h1>Computerens ressourcer</h1>

<p>De nedestående programmer er allesammen ret omfattende, så der er ikke en udførlig beskrivelse af hvordan man bruger dem. De er medtaget for at du kan få et indblik i den værktøjskasse der er tilgængelig når man anvender Ubuntu som server.</p>

<h2><span class="inl_cmd">free</span></h2>

<p><span class="inl_cmd">free</span> angiver forbruget af RAM, og vil normalt blive anvendt med <span class="inl_cmd">-h</span> eller <span class="inl_cmd">-g</span>, da det er mere læseligt. Se nedestående eksempler.</p>

<code class="cmd">free</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ free
             total       used       free     shared    buffers     cached
Mem:       4047396    1414588    2632808       5552     102484     824944
-/+ buffers/cache:     487160    3560236
Swap:      3999740          0    3999740
</pre>

<code class="cmd">free -h</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ free -h
             total       used       free     shared    buffers     cached
Mem:          3,9G       1,3G       2,5G       5,4M       100M       805M
-/+ buffers/cache:       475M       3,4G
Swap:         3,8G         0B       3,8G
</pre>

<p>For at forstå tallene skal man være klar over hvordan bruger vs linux forstår dem:</p>

<table class="centreret">
	<thead>
		<tr>
			<th>Hukommelse der...</th>
			<th>Du kalder det:</th>
			<th>Linux kalder det:</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>bliver anvendt af programmer</td>
			<td><span class="red">Brugt</span></td>
			<td><span class="red">Brugt</span></td>
		</tr>
		<tr>
			<td>er tilgængelig og anvendt til noget</td>
			<td><span class="green">Fri</span></td>
			<td><span class="red">Brugt</span></td>
		</tr>
		<tr>
			<td>ikke er anvendt</td>
			<td><span class="green">Fri</span></td>
			<td><span class="green">Fri</span></td>
		</tr>
	</tbody>
</table>

<p>Læs Mere: Linux ate my RAM! <a href="http://www.linuxatemyram.com/" target="_blank">http://www.linuxatemyram.com/</a></p>

<p>Derfor kan vi nu beregne mængden af fri RAM, ved at kigge på frie <span class="inl_cmd">-/+ buffers/cache</span></p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ free -h
             total       used       free     shared    buffers     cached
Mem:          3,9G       1,3G       2,5G       5,4M       100M       805M
-/+ buffers/cache:       475M       <span class="red">3,4G</span>
Swap:         3,8G         0B       3,8G
</pre>

<p>Læg mærke til hvordan free beregner RAM mængden. Der er 4GB RAM i den maskine <span class="inl_cmd">free -h</span> er blevet brugt på, men taller bliver rundet ned til 3,9GB.</p>

<p>Hvis du gerne vil se udviklingen af dit RAM forbrug kan du sætte <span class="inl_cmd">free</span> til at opdatere sig selv efter nogle sekunder <span class="inl_cmd">-sX</span>. Nedestående opdaterer sig selv efter 2 sek.</p>

<code class="cmd">free -g -s2</code>

<p>man-page: <span class="inl_cmd">free</span>
<a href="http://manpages.ubuntu.com/manpages/trusty/man1/free.1.html" target="_blank">
http://manpages.ubuntu.com/manpages/trusty/man1/free.1.html</a></p>



<h2><span class="inl_cmd">top</span></h2>

<p><span class="inl_cmd">top</span> er et program der giver informationer om processer. Programmet følger med de fleste Linux distributioner som standard. Programmet afbrydet med <kbd>Ctrl</kbd>+<kbd>c</kbd>.</p>

<pre class="ubuntu_terminal">
top - 11:36:32 up 2 min,  2 users,  load average: 0,23, 0,23, 0,10
Tasks: <span class="bold">170</span> total,   <span class="bold">2</span> running, <span class="bold">168</span> sleeping,   <span class="bold">0</span> stopped,   <span class="bold">0</span> zombie
%Cpu(s):  <span class="bold">7,0</span> us,  <span class="bold">1,7</span> sy,  <span class="bold">0,0</span> ni, <span class="bold">91,3</span> id,  <span class="bold">0,0</span> wa,  <span class="bold">0,0</span> hi,  <span class="bold">0,0</span> si,  <span class="bold">0,0</span> st
KiB Mem:   <span class="bold">4047396</span> total,   <span class="bold">702860</span> used,  <span class="bold">3344536</span> free,    <span class="bold">28392</span> buffers
KiB Swap:  <span class="bold">3999740</span> total,        <span class="bold">0</span> used,  <span class="bold">3999740</span> free.   <span class="bold">298104</span> cached Mem

<span class="white_bg">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND </span>     
 1037 root      20   0  442812  64476  24616 S  3,7  1,6   0:02.53 Xorg         
 2018 tj        20   0 1213008  94816  58028 S  3,3  2,3   0:01.90 compiz       
 2170 tj        20   0  576656  31360  22824 S  1,3  0,8   0:00.62 gnome-termi+ 
<span class="bold"> 2281 tj        20   0   30616   3024   2532 R  0,3  0,1   0:00.11 top </span>         
    1 root      20   0   33772   4348   2688 S  0,0  0,1   0:00.91 init         
    2 root      20   0       0      0      0 S  0,0  0,0   0:00.00 kthreadd     
    3 root      20   0       0      0      0 S  0,0  0,0   0:00.00 ksoftirqd/0  
    4 root      20   0       0      0      0 S  0,0  0,0   0:00.00 kworker/0:0  
    5 root       0 -20       0      0      0 S  0,0  0,0   0:00.00 kworker/0:0H 
    6 root      20   0       0      0      0 S  0,0  0,0   0:00.00 kworker/u2:0 
    7 root      20   0       0      0      0 S  0,0  0,0   0:00.03 rcu_sched    
    8 root      20   0       0      0      0 S  0,0  0,0   0:00.00 rcu_bh       
    9 root      20   0       0      0      0 R  0,0  0,0   0:00.03 rcuos/0      
   10 root      20   0       0      0      0 S  0,0  0,0   0:00.00 rcuob/0      
   11 root      rt   0       0      0      0 S  0,0  0,0   0:00.00 migration/0  
   12 root      rt   0       0      0      0 S  0,0  0,0   0:00.00 watchdog/0   
   13 root       0 -20       0      0      0 S  0,0  0,0   0:00.00 khelper      
</pre>
<p></p>

<h2><span class="inl_cmd">htop</span></h2>

<p><span class="inl_cmd">htop</span> er et interaktivt program til at kigge på processer og computerens ressourcer. Programmet tilbyder mange flere informationer end <span class="inl_cmd">top</span> , og er interaktivt. Man kan vælge med musen samt sortere og søge i data.</p>

<p>Programmet installeres med kommandoen:</p>

<code class="cmd">apt-get install htop -y</code>

<figure id="">

	<img class="" src="images/kommandoer_htop.png" alt="" title="" />

	<figcaption></figcaption>

</figure>

<h2><span class="inl_cmd">uptime </span></h2>

<p><span class="inl_cmd">uptime</span> giver informationer om hvor længe computeren har kørt, antallet af bruger der er logget på og systembelastningen i 1, 5 og 15 minutters intervaller
</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ uptime
 23:16:35 up 0 min,  2 users,  load average: 0,71, 0,19, 0,06
</pre>

<h1>Processer</h1>

<p>Når et program startes på et Linux system får processen en unik PID (Proces ID). Man kan komme ud for situationer hvor man har behov for at lukke processer ned, f.eks. hvis programmet låser eller at det opfører sig uhensigtsmæssigt. For at gøre dette anvendes programmerne  <span class="inl_cmd">ps</span> og <span class="inl_cmd">kill</span></h2>

<p>Processerne anvender den de rettigheder som brugeren der oprettede dem har. Dvs. at brugeren kan dræbe de processer som vedkommende selv har startet, inklusiv dem der er oprettet med <span class="inl_cmd">sudo</span>.</p>

<p>Eksemplerne herunder er langt fra uddybende, men giver et kort indblik i de muligheder man har som administrator på systemet.</p>

<h2><span class="inl_cmd">ps</span></h2>

<p><span class="inl_cmd">ps</span> anvendes til at få et overblik over de processer der kører på systemet. Her er et eksempel fra en nystartet terminal hvor vi kører kommandoen <span class="inl_cmd">ps</span>.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ps
  PID TTY          TIME CMD
 2215 pts/11   00:00:00 bash
 2227 pts/11   00:00:00 ps
</pre>

<p>Vi kan se at der kører to processer: <span class="inl_cmd">bash</span> (PID 2215) og <span class="inl_cmd">ps</span> (PID 2227). Vær opmærksom på at det ikke er alle de processer der kører på computeren, men kun dem som kører i den startede session. Ønsker du et overblik over alle de processer der kører på computeren skal du anvende følgende kommando: <span class="inl_cmd">ps aux</span>. Dette overblik er langt mere detaljeret.</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.2  0.1  33776  4260 ?        Ss   13:15   0:00 /sbin/init
root         2  0.0  0.0      0     0 ?        S    13:15   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S    13:15   0:00 [ksoftirqd/0]

<span class="red">... ( Linier udeladt )</span>

tj        2249  0.0  0.3 385332 13772 ?        Sl   13:18   0:00 zeitgeist-datah
tj        2254  0.0  0.1 265744  6000 ?        Sl   13:18   0:00 /usr/bin/zeitge
tj        2261  0.0  0.2 233188  9952 ?        Sl   13:18   0:00 /usr/lib/x86_64
tj        2270  0.0  0.0  12888   772 ?        S    13:18   0:00 /bin/cat
tj        2298  0.0  0.4 572816 19532 ?        Sl   13:19   0:00 update-notifier
tj        2316  0.0  0.1 461588  7592 ?        Sl   13:20   0:00 /usr/lib/x86_64
tj        2325  0.0  0.0  24120  2564 pts/11   R+   13:20   0:00 ps aux

</pre>

<h2><span class="inl_cmd">kill</span></h2>

<p>Når man kender processens ID kan man anvende <span class="inl_cmd">kill</span> til at lukke programet ned. <span class="inl_cmd">kill</span> har en lang række forskellige måder at lukke programmer på og det angives ved at tilføje en option. Ønsker du at dræbe en proces anvendes <span class="inl_cmd">-9</span>. Herunder angives en måde du kan prøve det selv:</p>

<p>Start en terminal og kør: <span class="inl_cmd">ps</span></p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ps
  PID TTY          TIME CMD
 2215 pts/11   00:00:00 bash
 2373 pts/11   00:00:00 ps
</pre>

<p>Herefter starter vi nano op i baggrunden ved at sætte <span class="inl_cmd">&amp;</span> efter kommandoen, hvorefter vi kører <span class="inl_cmd">ps</span>.</p>

<code class="cmd">nano & </code>
<code class="more_cmd">ps</code>


<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ nano &
[1] 2374
tj@tj-VirtualBox:~$ ps
  PID TTY          TIME CMD
 2215 pts/11   00:00:00 bash
 2374 pts/11   00:00:00 nano
 2375 pts/11   00:00:00 ps

[1]+  Stopped                 nano
tj@tj-VirtualBox:~$ 
</pre>

<p>For at dræbe nano anvender vi kommandoen <span class="inl_cmd">kill -9 *PID*</span> (i dette tilfælde 2374) og derefter kører vi <span class="inl_cmd">ps</span> for at se om processen er slettet:</p>

<code class="cmd">kill -9 2374</code>
<code class="more_cmd">ps</code>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ kill -9 2374
tj@tj-VirtualBox:~$ ps  
  PID TTY          TIME CMD
 2215 pts/11   00:00:00 bash
 2376 pts/11   00:00:00 ps
[1]+  Dræbt                  nano
</pre>

<p><span class="inl_cmd">kill</span> er et meget avanceret program, og indeholder mange måder at dræbe processer på. Hvis du ønsker at se alle mulighederne kan du anvende kommandoen <span class="inl_cmd">kill -l</span>.</p>

<h2>Afledte programmer til at dræbe finde/dræbe processer</h2>

<p>Man kan sagtens nøjes med <span class="inl_cmd">ps</span>, da man kan filtrere output med grep. F.eks. hvis man har startet firefox og vil finde processen</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ ps aux | grep firefox
tj        2380  7.5  6.5 1013652 263112 ?      Sl   13:39   0:27 /usr/lib/<span class="red">firefox</span>/<span class="red">firefox</span>
tj        2461  0.0  0.0  17436  2092 pts/11   S+   13:46   0:00 grep --color=auto <span class="red">firefox</span>
</pre>

<p>Som det ses herover bliver firefox fanget 2 gange. En for selve programmet og en som fanger søgningen efter firefox. Det er altså proces <span class="inl_cmd">2380</span> der skal lukkes ned. Der findes en række kommandoer som automatisk integrerer søgningen: <span class="inl_cmd">pgrep</span> og <span class="inl_cmd">pkill</span>. Herunder er vist nogle eksempler med firefox:</p>

<pre class="ubuntu_terminal">
tj@tj-VirtualBox:~$ pgrep firefox
2380
tj@tj-VirtualBox:~$ pkill firefox
tj@tj-VirtualBox:~$ pgrep firefox
tj@tj-VirtualBox:~$ 
</pre>

<p>Først køres <span class="inl_cmd">pgrep</span>, som finder processen. I anden omgang anvendes <span class="inl_cmd">pkill</span> til at lukke processen og <span class="inl_cmd">pgrep firefox</span> viser at processen ikke eksisterer mere</p>


<h2><span class="inl_cmd">xkill</span> - til GUI</h2>

<p><span class="inl_cmd">xkill</span> er et program man anvender i et GUI. Alle programmer kan låse eller gå langsom hvis der sker en fejl i operativsystemet. Hvis man ønsker at dræbe en proces i et GUI, åbner man en terminal og skriver xkill. Herefter vil ens cursor ændre sig til et kryds, og hvis man klikker på et vindue med dette, vil det dræbe den proces der kører det og give nedestående i terminalen.</p>

<pre class="ubuntu_terminal">
thoj@thoj:~$ xkill
Select the window whose client you wish to kill with button 1....
xkill:  killing creator of resource 0x4e00143
</pre>
<p></p>
<p></p>
<p></p>
<p></p>

	</body>

</html>
