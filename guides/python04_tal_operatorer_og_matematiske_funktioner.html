<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8" lang="da"/>

	<title>Python 3: Tal, operatorer og matematiske funktioner - Thomas Jensen</title>

	<link rel="stylesheet" href="../css/styles/docco.css" />

	<link rel="stylesheet" href="../css/style.css" />

	<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono|Ubuntu|Ubuntu+Condensed' rel='stylesheet' type='text/css'>
	
	<script src="../js/toc2.js" type="text/javascript"></script>
	<script src="https://code.jquery.com/jquery-2.2.2.js"></script>
	<script src="../js/highlight.pack.js" type="text/javascript"></script>
	<script>hljs.initHighlightingOnLoad();</script>


</head>

<!-- 

code highlighter : https://highlightjs.org/

code converter : http://www.freebits.co.uk/convert-html-code-to-text.html 

-->


<html>

<body onload="generateTOC(document.getElementById('toc'));">

<footer id="license"></footer>

	<script> $( "#license" ).load( "license.html" ); </script>

	<div id="toc">
	<p>Indholdsfortegnelse</p>
	
	</div>
	
<div class="title">Tal, operatorer og matematiske funktioner</div>
	
<figure id="">

	<img class="" src="images/python-logo-inkscape.svg" alt="" title="" />

	<figcaption></figcaption>

</figure>
		
<h1>Tal og operatorer</h1>

<p>Indtil videre har der været en naturlig progression i materialet, men herefter begynder tingene at blive mere komplekse. Derfor kommer der her et afsnit omkring anvendelse af logiske operatiorer, som anvendes til at sammenligne og adskille værdier.</p>

<h2>Integers og float</h2>

<p>Angående tal skal man ikke definere om man arbejder med heltal (også kaldet intergers) eller kommatal (floating point). De defineres sammen med variablen. Det er et af områder hvor Python virkeligt adskiller sig fra andre programmeringssprog, og det betyder at den som laver programmet ikke skal forholde sig til hvordan et tal skal anvendes. Python gør det automatisk for dig.</p>

<p>
Læg mærke til at man bruger punktum (<span class="inl_cmd">.</span>) til at angive overgangen mellem hel- og decimaltal.</p>

<pre>
	<code class="python">
# Sætter henholdsvis hel og kommatal

heltal = 3

kommatal = 3.14

print ("5*3 er {0} og 2 * pi (3,14) er {1}.".format(heltal*5, kommatal*2))
	</code>
</pre>

<pre class="ubuntu_terminal">
5*3 er 15 og 2 * pi (3,14) er 6.28.


------------------
(program exited with code: 0)
Press return to continue

</pre>

<h2>Computeren kan <s>ikke</s> tælle</h2>

<p>En af de ting man støder på når man arbejder med programmering er, at computere tæller anderledes end vi gør. Når vi tæller starter vi fra en, og titalssystemet er anvendeligt for os fordi det passer med antallet af fingre på på hånden. Når vi har brugt alle fingrene så tæller vi antallet af fulde hænder. 22 kan altså forståes som 2 fulde hænder og 2 fingre. I 10-talssystemet skifter vi altså position (veksler til den næste enhed) når vi kommer til den 10. værdi.</p>

<p>Til forskel fra en computer begynder vi ikke at tælle før vi har behov for det. Det er derfor vi definerer de naturlige tal som: &#8469; = {1, 2, 3, 4 ...}. Computeren anvender &#8469;<sub>0</sub> = {0, 1, 2, 3 ...}, fordi den først begynder at tælle når der bliver afsat hukommelse til det.</p>

<p>Computerens tællemekanisme består af transistorer som enten kan være slukket eller tændte. Det præsenterer vi ved tallene <span class="inl_cmd">0</span> og <span class="inl_cmd">1</span>. For at vise dette kigger vi på en byte (der består af 8 bit) der tæller:</p>

<table class="">
	<thead>
		<tr>
			<th>Computerens</th>
			<th colspan="8">bits</th>
			<th>I 10-tals systemet</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1. værdi</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>2. værdi</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>3. værdi</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>0</td>
			<td>2</td>
		</tr>
		<tr>
			<td>4. værdi</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
			<td>3</td>
		</tr>
		<tr>
			<td>5. værdi</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>0</td>
			<td>0</td>
			<td>4</td>
		</tr>
		<tr>
			<td>6. værdi</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>0</td>
			<td>1</td>
			<td>5</td>
		</tr>
		<tr>
			<td>7. værdi</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
			<td>0</td>
			<td>6</td>
		</tr>
		<tr>
			<td>8. værdi</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
			<td>1</td>
			<td>7</td>
		</tr>
		<tr>
			<td>9. værdi</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>8</td>
		</tr>
		<tr>
			<td>10. værdi</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>9</td>
		</tr>
		<tr>
			<td></td>
			<td>2⁷</td>
			<td>2⁶</td>
			<td>2⁵</td>
			<td>2⁴</td>
			<td>2³</td>
			<td>2²</td>
			<td>2¹</td>
			<td>2⁰</td>
			<td></td>
		</tr>
		<tr>
			<td>Værdi</td>
			<td>128</td>
			<td>64</td>
			<td>32</td>
			<td>16</td>
			<td>8</td>
			<td>4</td>
			<td>2</td>
			<td>1</td>
			<td></td>
		</tr>		
	</tbody>
</table>

<p>Af det ovenstående kan vi omregne fra binær til decimal ved at lægge de enkelte værdier sammen:</p>

<table class="">
	<thead>
		<tr>
			<th>Binær</th>
			<th colspan="8">Udregning</th>
			<th>Decimal</th>
		</tr>
	</thead>
	<tbody>

		<tr>
			<td></td>
			<td>2⁷</td>
			<td>2⁶</td>
			<td>2⁵</td>
			<td>2⁴</td>
			<td>2³</td>
			<td>2²</td>
			<td>2¹</td>
			<td>2⁰</td>
			<td></td>
		</tr>
		<tr>
			<td>11111111</td>
			<td>128</td>
			<td>64</td>
			<td>32</td>
			<td>16</td>
			<td>8</td>
			<td>4</td>
			<td>2</td>
			<td>1</td>
			<td>255</td>
		</tr>	
		<tr>
			<td>10101101</td>
			<td>128</td>
			<td></td>
			<td>32</td>
			<td></td>
			<td>8</td>
			<td>4</td>
			<td></td>
			<td>1</td>
			<td>173</td>
		</tr>
		<tr>
			<td>10000001</td>
			<td>128</td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td></td>
			<td>1</td>
			<td>129</td>
		</tr>
		<tr>
			<td>00101101</td>
			<td></td>
			<td></td>
			<td>32</td>
			<td></td>
			<td>8</td>
			<td>4</td>
			<td></td>
			<td>1</td>
			<td>45</td>
		</tr>
	</tbody>
</table>

<p>Det er vigtigt at man holder styr på hvilke tal og værdier der bliver brugt fra gang til gang. Nogle gange er det den menneskelige tællemmåde  &#8469; = {1, 2, 3, 4 ...} f.eks. når man tæller antallet af elementer i en tekstreng. Andre gange er det computerens &#8469;<sub>0</sub> = {0, 1, 2, 3 ...} f.eks. når man angiver tegnets position.</p>

<h2>Regningsregler</h2>

<pre>
	<code class="python">
print ("8 + 2 = {0}".format(8+2)) # addition

print ("8 - 2 = {0}".format(8-2)) # substraktion

print ("8 * 2 = {0}".format(8*2)) # Multiplikation

print ("8 / 2 = {0}".format(8/2)) # Division

print ("2**4 = {0}".format(2**4)) # Exponent

print ("10**-6 = {0}".format(10**-6)) # Negativ exponent

print ("( 8 * 2 ) - 4 = {0}".format((8*2)-4)) # Parantesregning

print ("8 * ( 2 - 4 ) = {0}".format(8 * ( 2 - 4 ))) # Parantesregning
	</code>
</pre>

<pre class="ubuntu_terminal">
8 + 2 = 10
8 - 2 = 6
8 * 2 = 16
8 / 2 = 4.0
2**4 = 16
10**-6 = 1e-06
( 8 * 2 ) - 4 = 12
8 * ( 2 - 4 ) = -16


------------------
(program exited with code: 0)
Press return to continue
</pre>

<p>En sidste regnemetode er <span class="inl_cmd">modulus</span>. Den anvendes til at finde restproduktet, som herunder hvor restproduktet af 9/5 = 4. Læg mærke til at jeg bliver nød til at skrive <span class="inl_cmd">%%</span> - altså to gange efter hinanden. Det er kun nødvendig når vi anvender pladsholdere og andre funktioner der starter med et %.</p>
<pre>
	<code class="python">
print ("9 %% 5 = {0}".format(9%5))
	</code>
</pre>

<pre class="ubuntu_terminal">
9 % 5 = 4


------------------
(program exited with code: 0)
Press return to continue

</pre>

<h2>En til eller fra</h2>

<p>Ofte har man brug for at lade et tal vokse med en fast størrelse fra gang til gang. Den mest umiddelbare løsning er denne:</p>

<pre>
	<code class="python">
a = 0

print(a)

a = a + 1

print(a)
	</code>
</pre>

<pre class="ubuntu_terminal">
0
1


------------------
(program exited with code: 0)
Press return to continue
</pre>

<p>Da man gør det så ofte har man en speciel "shorthand" til at løse dette problem med:</p>

<pre>
	<code class="python">
a = 0

print(a) 	# Print a

a +=1  		# Læg 1 til a

print(a) 	# Print a

a +=1 		#læg 1 til a

print(a)
	</code>
</pre>

<pre class="ubuntu_terminal">
0
1
2


------------------
(program exited with code: 0)
Press return to continue
</pre>

<p>På samme måde som ovenfor kan man også lægge til, gange og dividere</p>

<pre>
	<code class="python">
a = 1

print("a er {0}".format(a))

a+=5		# lægger 5 til = 6

print("a +=5 er {0}".format(a))

a -=7		# trækker 7 fra = -1

print("a -=7 er {0}".format(a))

a *=7		# ganger med 7 = -7

print("a *=7 er {0}".format(a))

a /=7		# dividerer med 7 = -1

print("a /=7 er {0}".format(a))
	</code>
</pre>

<pre class="ubuntu_terminal">
a er 1
a +=5 er 6
a -=7 er -1
a *=7 er -7
a /=7 er -1.0
</pre>



<h2>Integer og float</h2>

<p>Python ser tal som hel- eller decimaltal. I programmerings sprog kaldes heltallet for en interger (latin: hel, komplet) og decimaltallet float (Eng: Flydende)</p>

<p>I det ovenstående divisionseksempel svarede Python med et decimaltal (float). Det skyldes at Python er designet til at være så simpelt at gå til som muligt, da langt de fleste divisionsstykker resluterer i decimaltal. Derfor skal vi fortælle Python at tallet skal tolkes som et heltal (interger).</p>

<p>I eksemplet herunder vises først hvordan man konverterer ovenstående resultat til en interger ved at indsætte det i funktionen <span class="inl_cmd">int()</span></p>

<pre>
	<code class="python">
a = -7

a /=7		# dividerer med 7 = -1

print ("I dette eksempel er resulatet et heltal\n")

print("\t-7 divideret med 7 er (integer) = {0}".format(int(a)))

print("\t-7 divideret med 7 er (float) = {0}".format(a))
	</code>
</pre>

<pre class="ubuntu_terminal">
I dette eksempel er resulatet et heltal

	-7 divideret med 7 er (integer) = -1
	-7 divideret med 7 er (float) = -1.0


------------------
(program exited with code: 0)
Press return to continue
</pre>

<p>Man skal dog være påpasselig med hvordan det anvendes som det kan ses i eksemplet herunder. Hvis resultatet ikke er et heltal vil det blive rundet af og man mister decimalerne.</p>

<pre>
	<code class="python">
b = 5

b /=4 		# dividere med 4 = 1,25

print ("\nI dette eksempel er resulatet et decimaltal\n")

print("\t5 divideret med 4 er (float) = {0}".format(b))

print("\t5 divideret med 4 er (interger) = {0}".format(int(b)))
	</code>
</pre>

<pre class="ubuntu_terminal">
I dette eksempel er resulatet et decimaltal

	5 divideret med 4 er (float) = 1.25
	5 divideret med 4 er (interger) = 1


------------------
(program exited with code: 0)
Press return to continue
</pre>

<p>Hvis du ønsker at finde ud af om et tal er en interger eller float, kan du teste det ved hjælp af <span class="inl_cmd">is_interger()</span>.</p>

<pre>
	<code class="python">
a = 2.45

test1 = a.is_integer()

print ("%s er en integer: {0}".format(a, test1))
	</code>
</pre>

<pre class="ubuntu_terminal">
2.45 er en integer: False


------------------
(program exited with code: 0)
Press return to continue
</pre>

<h2>Brøker</h2>

<p>For at arbejde med brøker skal man "tvinge" python til ikke at regne brøken ud. Det kan være nødvendig for ikke at få afrundingsfejl. For at kunne anvende brøker skal vi importere modulet fractions. Herunder er givet et eksempel ved hjælp at et GRUK af Piet Hein, hvor der er vist forskellen mellem at anvende <span class="inl_cmd">fractions()</span> og <span class="inl_cmd">float</span>.</p>

<pre>
	<code class="python">
from fractions import Fraction

brøk1 = Fraction(3, 4) # brøken 3/4;

brøk2 = Fraction(2,3) #brøken 2/3; 

brøk3 = brøk1 * brøk2

brøk1_udr = 3/4

brøk2_udr = 2/3

brøk3_udr = brøk1_udr * brøk2_udr


print ("""
En halv
er
tænk nu hvor aparte
to tredjedele
af tre kvarte
	(Piet Hein)
""")

print ("Udskrevet ved hjælp af Fractions: {0} = {1} * {2}".format(brøk3, brøk2, brøk1))

print ("\nUdskrevet ved hjælp af float: {0} = {1} * {2}".format(brøk3_udr, brøk2_udr, brøk1_udr))
	</code>
</pre>

<pre class="ubuntu_terminal">
En halv
er
tænk nu hvor aparte
to tredjedele
af tre kvarte
	(Piet Hein)

Udskrevet ved hjælp af Fractions: 1/2 = 2/3 * 3/4

Udskrevet ved hjælp af float: 0.5 = 0.6666666666666666 * 0.75


------------------
(program exited with code: 0)
Press return to continue
</pre>

<p>Som det kan ses bliver 2/3 omskrevet til 0,666... hvilket kun er en tilnærmet værdi.</p>

<h2>Faktorer</h2>

<p>Når man opløser et tal i faktorer finder man ud af hvilke tal der går et bestemt tal. F.eks. er 28 = 2 &#8226; 2 &#8226; 7. Python har ikke en indbygget funktion hertil men den laver vi selv. Hvis <span class="inl_cmd">modulus</span> (se ovenfor) er 0, så er tallet en faktor ellers ikke.</p>

<pre>
	<code class="python">

tal = int(input("hvilket tal vil du undersøge?: "))

faktor = int(input("Skriv den faktor du vil undersøge tallet med: "))



print("Hvis {0} delt med {1} er 0, er {1} faktor i {0} = {2}".format(faktor,tal,tal%faktor))
	</code>
</pre>

<pre class="ubuntu_terminal">
hvilket tal vil du undersøge?: 100
Skriv den faktor du vil undersøge tallet med: 10
Hvis 10 delt med 100 er 0, er 100 faktor i 10 = 0


------------------
(program exited with code: 0)
Press return to continue
</pre>


<h2>Absolutte tal</h2>

<p>Funktionen <span class="inl_cmd">abs()</span> returnere altid en værdi som værende positiv. Det giver mening hvis man f.eks. ønsker at finde forskellen mellem to tal uden at skulle forholde sig til rækkefølgen de kommer i. Som i eksemplet herunder hvor første udregning med <span class="inl_cmd">abs()</span> kun fortæller forskellen, men den anden fortæller om det er en stigning eller et fald.</p>

<pre>
	<code class="python">
temperatur1 = 18 # temperatur kl. 12.00

temperatur2 = 20 # temperatur kl. 15.00

forskel = temperatur1 - temperatur2

print ("Forskel i temperatur: {0}".format(abs(forskel)))

print ("temperatur-stigning/fald: {0}".format(forskel))
	</code>
</pre>

<pre class="ubuntu_terminal">
Forskel i temperatur: 2
temperatur-stigning/fald: -2


------------------
(program exited with code: 0)
Press return to continue
</pre>

<h2>Operatorer</h2>

<p>Operatorer beskriver forholdet mellem to værdier</p>

<table class="">
	<thead>
		<tr>
			<th>Operator</th>
			<th>Beskrivelse</th>
			<th>Eksempel</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>&gt;</td>
			<td>større end</td>
			<td>5 &gt; 8 → falsk</td>
		</tr>
		<tr>
			<td>&lt;</td>
			<td>mindre end</td>
			<td>5 &lt; 8 → sand</td>
		</tr>
		<tr>
			<td>&gt;=</td>
			<td>Større end eller lig med</td>
			<td>5 &gt;= 8 → falsk</td>
		</tr>
		<tr>
			<td>&lt;=</td>
			<td>Mindre end eller lig med</td>
			<td>5 &lt;= 8 → sand</td>
		</tr>
		<tr>
			<td>==</td>
			<td>Lig med</td>
			<td>5 == 8 → falsk</td>
		</tr>
		<tr>
			<td>!=</td>
			<td rowspan="2">Ikke lig med</td>
			<td>5 != 8 → sand</td>
		</tr>
		<tr>
			<td>&lt;&gt;</td>

			<td>5 &lt;&gt; 8 → sand</td>
		</tr>
		<tr>
			<td>is</td>
			<td>Identisk med</td>
			<td>5 is "5" → falsk</td>
		</tr>
		<tr>
			<td>is not</td>
			<td>Ikke identisk med</td>
			<td>5 is not "5" → sand</td>
		</tr>
		<tr>
			<td>x and y</td>
			<td >Både x og y skal være sand</td>
			<td >x=6 ; y=3<br /><br />(x &lt; 10 and y &gt; 1) →  sand</td>
		</tr>
		<tr>
			<td>x or y</td>
			<td>Kun en behøver at være sand</td>
			<td>x=6 ; y=3<br /><br/>(x == 6 or y == 1) → sand</td>
		</tr>
	</tbody>
</table>

<span class="afsnit">VIGTIGT</span>

<p>De to sidste: <span class="inl_cmd">and</span> / <span class="inl_cmd">or</span> skal vi som danskere være meget forsigtige med, fordi de er logiske og ikke sproglige. Et eksempel kan være hvor betingelsen er, at man både kan svare med <span class="inl_cmd">j</span> og <span class="afsnit">J</span> - altså både det lille og det store bogstav. Umiddelbart ville nedestående linie give mening:</p>
	
<pre>
	<code class="python">
if valg ==  "j" and valg == "J" : #Gælder for både lille <span class="bold">og</span> store J
	</code>
</pre>

<p>Sprogligt giver det mening, men problemet er, at brugeren aldrig vil kunne taste både j og J på samme tid. Så derfor vil Python afvise begge indtastninger. Det er ikke Python der laver fejl, men mere et udtryk for at det danske sprog er finurligt og ulogisk. F.eks. så kan vi også finde på at spørge: "er det ikke sjovt" .. når vi faktisk mener "er det sjovt". Det er ikke kun udlændninge der synes vores sprog er ulogisk.</p>

<h2>Afgrænsede områder</h2>

<p>Nogle gange har man brug for at kunne afgrænse områder. Forestil dig at vi skal udvælge brugere der er fra 15 år til og med 22. Det matematiske udsagn ville være <span class="inl_cmd">15 &le; x &le; 22</span>. I Python skal vi splitte det op i to udsagn hvor vi skal beskrive den ned grænse og den øvre grænse ud fra x: <span class="inl_cmd">x &gt;= 15 <span class="blue">and</span> x &gt;= 22</span>.</p>

<h1>Matematiske funktioner</h1>

<p>For at anvende Phytons matematiske funktioner skal man inkludere programbiblioteket math. Det kan gøres på to måder - enten ved at inkludere alle matematikfunktionerne eller ved kun at importere enkelte derfra. På den måde kan man sparepå hukommelsen.</p>

<p>Herunder er de to metoder vist med henholdsvis kvadratrod og 10-tals logaritmen. Først den generelle. Læg mærke til at der skal angives fra hvilket programbibliotek den matematiske funktion skal tages fra.</p>

<pre>
	<code class="python">
import math

print (math.sqrt(27))

print (math.log10(100))
	</code>
</pre>

<pre class="ubuntu_terminal">
5.19615242271
2.0


------------------
(program exited with code: 0)
Press return to continue
</pre>

<p>For kun at importere de nødvendige elementer fra programbiblioteket anvendes <span class="inl_cmd">from *bibliotek* import *funktioner*</span>. De enkelte funktioner adskilles med et <span class="inl_cmd">,</span>. Det er heller ikke nødvendigt at definere fra hvilket bibliotek  elementerne kommer fra.</p>

<pre>
	<code class="python">
from math import sqrt, log10

print (sqrt(27))

print (log10(100))
	</code>
</pre>

<pre class="ubuntu_terminal">
5.19615242271
2.0


------------------
(program exited with code: 0)
Press return to continue
</pre>

<p>Af vigtige matematiske funktioner kan nævnes</p>

<h2>Konstanter</h2>

<p></p>

<table class="">
	<thead>
		<tr>
			<th>Konstant</th>
			<th>Beskrivelse</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>math.pi</td>
			<td>&pi; = 3.141592...</td>
		</tr>
		<tr>
			<td>math.e</td>
			<td>e = 2.718281...</td>
		</tr>
	</tbody>
</table>


<h2>Logaritmer</h2>

<p></p>

<table class="">
	<thead>
		<tr>
			<th>Funktion</th>
			<th>Inverse funktion</th>
			<th>Beskrivelse</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>math.exp</td>
			<td>math.log(x)</td>
			<td>Den naturlige logaritmen</td>
		</tr>
		<tr>
			<td>math.pow(10,x)</td>
			<td>math.log10(x)</td>
			<td>Titals logaritmen</td>
		</tr>
	</tbody>
</table>

<h2>Trigonometriske funktioner</h2>

<table class="">
	<thead>
		<tr>
			<th>Funktion</th>
			<th>Inverse funktion</th>
			<th>Beskrivelse</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>math.cos(x)</td>
			<td>math.acos(x)</td>
			<td>Cosinus</td>
		</tr>		
		<tr>
			<td>math.sin(x)</td>
			<td>math.asin(x)</td>
			<td>Sinus</td>
		</tr>	
		<tr>
			<td>math.tan(x)</td>
			<td>math.atan(x)</td>
			<td>Tangens</td>
		</tr>
		<tr>
			<td colspan="2">math.degrees()</td>
			<td>Konverterer fra rad til grader</td>
		</tr>	
		<tr>
			<td colspan="2">math.radians()</td>
			<td>Konverterer fra grader til rad</td>
		</tr>
	</tbody>
</table>

<h2>Talsystemer</h2>

<p>For at konvertere tal med anden base til 10 talssystemet anvendes <span class="inl_cmd">int()</span>. Det fungerer ved at man i parantesen skriver tallet man vil konvertere og basen der skal konverteres fra.</p>

<pre>
	<code class="python">
print ("100 i binært talsystem er\t"), int("100",2)

print ("100 i 8-talssystemet (octet) er\t"), int("100",8)

print ("100 i 10-talssystemet er\t"), int("100",10)

print ("100 i 16-talssystemet (hex) er\t"), int("100",16)
	</code>
</pre>

<pre class="ubuntu_terminal">
100 i binært talsystem er	4
100 i 8-talssystemet (octet) er	64
100 i 10-talssystemet er	100
100 i 16-talssystemet (hex) er	256


------------------
(program exited with code: 0)
Press return to continue

</pre>

<p>Der er indbygget konvertere fra ti-talssystemet til binær, octet og hexadecimalt talsystem. Det gøres ved at anvende <span class="inl_cmd">bin(), oct() og hex()</span> .</p>

<pre>
	<code class="python">
print ("100 er:")

print ("----------------------------------------------")

print ("{0} \ti det binære talsystem".format( bin(100)))

print ("{0} \t\ti 8-talssystemet".format(oct(100)))

print ("{0} \t\ti det hexadecimale talsystem".format(hex(100)))
	</code>
</pre>

<pre class="ubuntu_terminal">
100 er:
----------------------------------------------
0b1100100 	i det binære talsystem
0144 		i 8-talssystemet
0x64 		i det hexadecimale talsystem


------------------
(program exited with code: 0)
Press return to continue
</pre>

<p>Hvis du vil fjerne de tal der står foran værdien (f.eks. 0b i det binære) kan du "slice" ved at sætte <span class="inl_cmd">[:2]</span></p>

<pre>
	<code class="python">
print ("100 er:")

print ("----------------------------------------------")

print ("{0} \ti det binære talsystem".format( bin(100)[2:]))

print ("{0} \t\ti 8-talssystemet".format(oct(100)[2:]))

print ("{0} \t\ti det hexadecimale talsystem".format(hex(100)[2:]))
	</code>
</pre>

<pre class="ubuntu_terminal">
100 er:
----------------------------------------------
1100100 	i det binære talsystem
144 		i 8-talssystemet
64 		i det hexadecimale talsystem


------------------
(program exited with code: 0)
Press return to continue
</pre>

<h1>Random</h1>

<p>Ofte har man brug for at computeren skal kunne levere et tilfældigt tal. Det kan feks. være hvis computeren skal udvælge et element i en liste eller skal simulere terningkast. For at kunne anvende Random skal det først importeres, hvorefter vi får adgang til dets funktioner. Den væsentligste forskel ligger i hvordan det bliver præsenteret i koden. Lad os se på det første eksempel:</p>

<pre>
	<code class="python">
from random import random, randrange

print(random())

print(randrange(1,6))

	</code>
</pre>

<pre class="ubuntu_terminal">
0.15011231380396195
4


------------------
(program exited with code: 0)
Press return to continue
</pre>

<p>I dette eksempel importeres enkelt elementerne fra modulet. Det gør at vi kan kalde modulets funktioner direkte i vores kode. Dvs. for at kunne lave et random tal skal vi blot angive <span class="inl_cmd">random()</span>).</p>

<p>Hvis vi blot importerer modulet skal vi hver gang vi anvender noget fra modulet angive både modulets navn og funktion (<span class="inl_cmd">random.random()</span>).</p>

<pre>
	<code class="python">
import random

print(random.random())

print(random.randrange(1,6))
	</code>
</pre>

<p>Begge metoder har deres fordele. Fordelen ved at importere de enkelte moduler hver for sig er, at man i koden kan kalde den konkrete funktion uden at skulle skrive modulets navn først, samt at alle anvendte funktioner står i toppen af dokumentet. Fordelen ved at kalde hele funktionen er, at man i koden kan se når funktioner kaldes fra moduler. Det vigtigste er at du som programmør har overblikket over din kode og det er herudfra du skal vælge.</p>

<h2>Opgaver</h2>

<h3>Opgave - Terningspil 1</h3>

<p>Lav et program hvor man skal spille terning mod computeren.</p>

<ul class="disc">
	<li>Terningen bliver kastet 1 gang</li>
	<li>Brugeren skal kunne indtaste sit svar</li>
	<li>Output skal være om computer eller bruger er vinder</li>
</ul>

<h3>Opgave - Terningspil 2</h3>

<p>Ændre koden: </p>

<ul class="disc">
	<li>så brugeren skal vælge mellem en D4, D6, D10 og D20 terning</li>
	<li>Vælger antallet af slag</li>
	<li>Computeren udnævner en vinder og laver en udskrift af hvor mange gange henholdsvis bruger og computer har vundet og antallet af uafgjorte runder.</li>
</ul>

<p></p>

<pre class="ubuntu_terminal">
Spil terning mod computeren

Hvad er dit navn: Thomas
 4)  D4
 6)  D6
10)  D10
20)  D20

Hvilken terning vil du slå med.
Vælg antallet af sider på terningen. (4, 6, 10, 20): 20
Hvor mange omgange skal der spilles?: 10000

-----------------------------------------

Her er resultatet af spillet mellem dig og computeren

Der blev spillet med en D20 terning og var med 10000 slag

Lige: 543
Thomas: 4730
Computer: 4727

-----------------------------------------
Thomas vandt


(program exited with code: 0)
Press return to continue
</pre>

<h3>Opgave - Ordsprog</h3>

<p>Lav ved hjælp af en dictionary et program, som udskriver et tilfældigt ordsprog når det startes.</p>



<p></p>

<p></p>

<p></p>



	</body>

</html>
