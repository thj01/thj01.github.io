<!DOCTYPE html>

<head>
	
	<meta charset="UTF-8" lang="da"/>

	<title>MySQL - Opret database - Thomas Jensen</title>

	<link rel="stylesheet" href="../css/styles/docco.css" />

	<link rel="stylesheet" href="../css/style.css" />

	<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono|Ubuntu|Ubuntu+Condensed' rel='stylesheet' type='text/css'>
	
	<script src="../js/toc2.js" type="text/javascript"></script>
	<script src="https://code.jquery.com/jquery-2.2.2.js"></script>
	<script src="../js/highlight.pack.js" type="text/javascript"></script>
	<script>hljs.initHighlightingOnLoad();</script>

</head>

<!-- 

code highlighter : 

code converter : http://www.freebits.co.uk/convert-html-code-to-text.html 




-->



<html>

<body onload="generateTOC(document.getElementById('toc'));">

<footer id="license"></footer>

	<script> $( "#license" ).load( "license.html" ); </script>

	<div id="toc">
	<p>Indholdsfortegnelse</p>
	
	</div>

<div class="title">MySQL - Opret en database</div>

<h1>Installation af XAMPP</h1>

<p>For at kunne arbejde med MySQL skal den installeres. På windows er det lettest at installere en samlet pakke, som giver adgang til en fuld webserver, da det hele er konfigureret fra start. Her anbefales det at du anvender <a href="https://www.apachefriends.org/index.html" target="_blank">XAMPP</a>.</p>

<h2 id="tilbage">Installer XAMPP</h2>

<p>Du kan vælge at installere XAMPP på to måder:</p>

<ol class="">
	<li>Rigtig installation via <a href="https://www.apachefriends.org/index.html" target="_blank">https://www.apachefriends.org/index.html</a></li>
	<li>Portable installation via <a href="http://portableapps.com/apps/development/xampp" target="_blank">http://portableapps.com/apps/development/xampp</a>. (ikke Lite-versionen).</li>
</ol>

<p>Hvis du vil have en gennemgang af installationen så gå ind på denne side: <a href="http://www.vidas.dk/undervisning/mySQL_installer_XAMPP.html" target="_blank">http://www.vidas.dk/undervisning/mySQL_installer_XAMPP.html</a></p>


<h1>Overblik over phpMyAdmin</h1>


<h2>Hovedvindue</h2>

<p></p>

<figure id="">

	<img class="p90" src="images/mysql_main_window_01.png" alt="" title="" />

	<figcaption></figcaption>

</figure>

<h2>Databaser</h2>

<p></p>

<figure id="">

	<img class="" src="images/mysql_main_window_Databaser.png" alt="" title="" />

	<figcaption></figcaption>

</figure>

<h2>SQL</h2>

<p></p>


<figure id="">

	<img class="" src="images/mysql_main_window_SQL.png" alt="" title="" />

	<figcaption></figcaption>

</figure>

<h2>Status</h2>

<p></p>

<figure id="">

	<img class="" src="images/mysql_main_window_Status.png" alt="" title="" />

	<figcaption></figcaption>

</figure>

<h2>Brugerkonti</h2>

<p></p>

<figure id="">

	<img class="" src="images/mysql_main_window_Brugerkonti.png" alt="" title="" />

	<figcaption></figcaption>

</figure>

<h1>Grundbegreber</h1>

<span class="afsnit">Database</span>

<p></p>

<span class="afsnit">Tabel</span>

<p></p>

<span class="afsnit">Post</span>

<p></p>

<span class="afsnit">Felt</span>

<p></p>

<span class="afsnit">Nøgle</span>

<p></p>

<h1>Datatyper</h1>

<p>Herunder kan du se de mest anvendte datatyper. 

<p>Læs mere: <a href="http://dev.mysql.com/doc/refman/5.7/en/data-types.html" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/data-types.html</a></p>

<p>Læs mere: <a href="http://www.w3schools.com/sql/sql_datatypes.asp" target="_blank">http://www.w3schools.com/sql/sql_datatypes.asp</a></p>

<h2>Heltal - Integers</h2>

<p></p>

<table class="">
	<thead>
		<tr>
			<th rowspan="2">Datatype</th>
			<th rowspan="2">Størrelse <br/>(byte)</th>
			<th colspan="2"></th>
			<th colspan="2">UNSIGNED</th>
		</tr>
		<tr>
			<th>Min. værdi</th>
			<th>Maks. værdi</th>
			<th>Min. værdi</th>
			<th>Maks. værdi</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>TINYINT</td>
			<td>1</td>
			<td>-128</td>
			<td>127</td>
			<td>0</td>
			<td>255</td>
		</tr>
		<tr>
			<td>SMALLINT</td>
			<td>2</td>
			<td>-32768</td>
			<td>32767</td>
			<td>0</td>
			<td>65535</td>
		</tr>
		<tr>
			<td>MEDIUMINT</td>
			<td>3</td>
			<td>-8388608</td>
			<td>8388607</td>
			<td>0</td>
			<td>16777215</td>
		</tr>
		<tr>
			<td>INT</td>
			<td>4</td>
			<td>-2147483648</td>
			<td>2147483647</td>
			<td>0</td>
			<td>4294967295</td>
		</tr>
	</tbody>
</table>

<p>For at præcisere dine tal kan man "låse" antallet af cifre ved at angive det i en parantes. F.eks. vil <span class="inl_cmd">SMALLINT(4)</span> gøre, at feltet maksimalt kan indeholde 4 cifre. Det eneste du skal være opmærksom på er, at man ikke kan overskride antallet af cifre i den type man anvender f.eks: <span class="inl_cmd">TINYINT(4)</span>, da typens maksimale værdi er <span class="inl_cmd">255</span>.</p>

<p>Læs mere om heltal: <a href="http://dev.mysql.com/doc/refman/5.7/en/integer-types.html" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/integer-types.html</a></p>

<h2>Decimaltal</h2>

<p>Der findes to metoder til at anvende decimaltal. Den ene er binær og den anden er baseret på 10 talssystemet. Grunden til at man anvender to forskellige er, den hastighed systemet kan anvende tallene med og belastningen af CPU'en. Computeren er hurtigere til at regne med binære tal end tal fra 10 talssystemet. Se nedestående skema:</p>

<table class="">
	<thead>
		<tr>
			<th>Datatype</th>
			<th>Størrelse <br/>(byte)</th>
			<th>Talsystem</th>
			<th>Antal cifre/decimaler (præcission)</th>
			<th>Anvendelsesområde</th>
			<th>Nøjagtighed</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>FLOAT</td>
			<td>4</td>
			<td>Binær</td>
			<td>&sim; 7 decimaler</td>
			<td>Videnskabeligt</td>
			<td>Præcis</td>
		</tr>
		<tr>
			<td>DOUBLE</td>
			<td>8</td>
			<td>Binær</td>
			<td>&sim; 14 decimaler</td>
			<td>Videnskabeligt</td>
			<td>Præcis</td>
		</tr>
		<tr>
			<td>Decimal</td>
			<td>-</td>
			<td>10</td>
			<td>65 cifre, maks. 30 decimaler</td>
			<td>Financiel</td>
			<td>Eksakt</td>
		</tr>
	</tbody>
</table>

<span class="afsnit">Forskel på videnskabelig og "almindelige" tal</span>

<p>Videnskabelige tal angives ved hjælp af et heltal efterfulgt af en 10'er potens der angiver kommaets position f.eks. som ved Faradays konstant (F' = 9,6485309 &sdot; 10<sup>4</sup> C/mol). I decimaltal vil det være 96485,309 C/mol. Det som er problemet med det tal jeg skriver her er, at det reelt kun er præcist ned til den 7'ende decimal. Det er rigeligt i videnskabelig sammenhæng, men kan være mangelfuldt i andre sammenhænge f.eks. finansielle beregninger. Dette er årsagen til, at <span class="inl_cmd">FLOAT</span> og <span class="inl_cmd">DOUBLE</span> bliver angivet som værende præcise, og <span class="inl_cmd">DECIMAL</span> til at være eksakt.</p>

<p>Sagt på en anden måde. <span class="inl_cmd">FLOAT</span> og <span class="inl_cmd">DOUBLE</span> er præcise nok til at arbejde med tal, hvor der kun er brug for et mindre antal decimaler (videnskab), men ikke når der er brug for mange (finans).</p>

<p>Ligesom ved heltallene kan decimaltallene også præciseres (låses) ved hjælp af at angive antallet af cifre og decimaler i en parantes bagefter f.eks: DECIMAL(10,4). Det svarer til 10 cifre hvoraf de 4 er decimaler f.eks: 345987.4563</p>



<p>Læs mere: <a href="http://code.rohitink.com/2013/06/12/mysql-integer-float-decimal-data-types-differences/" target="_blank">http://code.rohitink.com/2013/06/12/mysql-integer-float-decimal-data-types-differences/</a></p>

<p>Om <span class="inl_cmd">FLOAT</span> og <span class="inl_cmd">DOUBLE</span>: <a href="http://dev.mysql.com/doc/refman/5.7/en/floating-point-types.html" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/floating-point-types.html</a></p>

<p>Om <span class="inl_cmd">DECIMAL</span>: <a href="http://dev.mysql.com/doc/refman/5.7/en/fixed-point-types.html" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/fixed-point-types.html</a></p>


<h2>Teksstrenge</h2>

<span class="afsnit">VARCHAR()</span>

<p><span class="inl_cmd">VARCHAR(*antal_tegn*)</span> gemmer op til det antal tegn (0-65635) der bliver sat i parantesen. Se skemaet herunder:</p>

<table class="">
	<thead>
		<tr>
			<th>Teksttreng</th>
			<th>VARCHAR(5)</th>
			<th>Beskrivelse</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>''</td>
			<td>''</td>
			<td>Ingen tegn bliver glemt</td>
		</tr>
		<tr>
			<td>'abc'</td>
			<td>'abc'</td>
			<td>abc bliver gemt</td>
		</tr>
		<tr>
			<td>'abcdefgh'</td>
			<td>'abcde'</td>
			<td>fgh bliver ikke gemt da det er udover de 5 tegn.</td>
		</tr>
	</tbody>
</table>

<p>Felternes størrelse er afhængig af indholdet</p>

<p>Læs mere: <a href="http://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/char.html</a></p>

<span class="afsnit">CHAR()</span>

<p><span class="inl_cmd">CHAR(*antal_tegn*)</span> gemmer det antal tegn (0-255) der bliver sat i parantesen. Se skemaet herunder:</p>

<table class="">
	<thead>
		<tr>
			<th>Teksttreng</th>
			<th>CHAR(5)</th>
			<th>Beskrivelse</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>''</td>
			<td>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'</td>
			<td>5 tomme tegn.</td>
		</tr>
		<tr>
			<td>'abc'</td>
			<td>'abc&nbsp;&nbsp;'</td>
			<td>abc og 2 tomme tegn.</td>
		</tr>
		<tr>
			<td>'abcdefgh'</td>
			<td>'abcde'</td>
			<td>fgh bliver ikke gemt da det er udover de 5 tegn.</td>
		</tr>
	</tbody>
</table>

<p>Felternes størrelse er afhængig af værdien der er sat.</p>

<p>Læs mere: <a href="http://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/char.html</a></p>

<span class="afsnit">Hvornår anvende VARCHAR() og CHAR()</span>

<p>Hvis man er i tvivl bør man altid anvende VARCHAR(). Kan man holde alle sine data til CHAR() kan det i nogle tilfælde give en hastighedsfordel, men det kræver igen store databaser før det er en reel effekt.</p>

<span class="afsnit">ENUM()</span>

<p>Med <span class="inl_cmd">ENUM()</span> kan man angive nogle foruddefinerede værdier som feltet kan indeholde. Det kan f.eks. være tøjstørrelser: <span class="inl_cmd">ENUM('X-SMALL','SMALL','MEDIUM','LARGE','X-LARGE','XX-LARGE')</span>. Fordelen ved at anvende <span class="inl_cmd">ENUM()</span> til at lagre værdier er, at de fylder langt mindre end <span class="inl_cmd">VARCHAR</span>, da værdierne bliver gemt i feltet som et tal der henviser til den konkrete tekststreng. 0 &#8594; X_SMALL, 1 &#8594; SMALL, 2 &#8594; MEDIUM osv. </p>

<p>Læs mere: <a href="http://dev.mysql.com/doc/refman/5.7/en/enum.html" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/enum.html</a></p>

<h2>Tid</h2>

<table class="">
	<thead>
		<tr>
			<th>Datatype</th>
			<th>Format</th>
			<th>Første værdi</th>
			<th>Sidste værdi</th>
			<th>Opdaterbar</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>DATE</td>
			<td>YYYY-MM-DD</td>
			<td>1000-01-01</td>
			<td>9999-12-31</td>
			<td>Nej</td>
		</tr>
		<tr>
			<td>DATETIME</td>
			<td>YYYY-MM-DD HH:MM:SS</td>
			<td>1000-01-01 00:00:00</td>
			<td>9999-12-31 23:59:59</td>
			<td>Ja</td>
		</tr>
		<tr>
			<td>TIMESTAMP</td>
			<td>YYYY-MM-DD HH:MM:SS</td>
			<td>1970-01-01 00:00:00</td>
			<td>2038-01-19 03:14:07</td>
			<td>Ja</td>
		</tr>
		<tr>
			<td colspan="5">YYYY = År , MM = måned , DD= dag , HH = timer , MM = minutter , SS = sekunder</td>
		</tr>

	</tbody>
</table>

<p><span class="inl_cmd">DATETIME</span> og <span class="inl_cmd">TIMESTAMP</span> kan sættes til at opdatere automatisk når en post bliver bliver oprettet eller ændret. Begge datatyper kan også tilføjes en værdi for dele af sekundet til en præcission på mikrosekunder (6 decimaler). Det gøres ved at indsætte præcissionen i en parantes efter datatypen f.eks: <span class="inl_cmd">DATETIME(3)</span>, hvilket angiver tusindedele af et sekund.</p>

<p>Læs mere: <a href="http://dev.mysql.com/doc/refman/5.7/en/datetime.html" target="_blank">http://dev.mysql.com/doc/refman/5.7/en/datetime.html</a></p>

<span class="afsnit">TIME()</span>

<p></p>


<h1>Normalisering</h1>

<p>En database er grundlæggende en samling data der er organiseret i rækker og kolonner. I rækkerne (kaldes også en <span class="inl_cmd">post</span>) har vi de enkelte opslag og i kolonnerne de kategorier opslaget skal indeholde. Herunder er et skema over mentorfordelingen på en mindre skole. </p>

<table class="">
	<thead>
		<tr>
			<th>Mentor</th>
			<th>Klasse 1</th>
			<th>Klasse 2</th>
			<th>Klasse 3</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>Thomas (tj)</td>
			<td>1a (17 elever)</td>
			<td>2a (22 elever)</td>
			<td>3a (21 elever)</td>
		</tr>
		<tr>
			<td>Bent (ba)</td>
			<td>1b (16 elever)</td>
			<td>2b (24 elever)</td>
			<td>3b (22 elever)</td>
		</tr>
	</tbody>
</table>

<p>Skemaet ovenfor er let at læse for os, men det for at gøre det til effektiv til en database skal vi anvende <span class="inl_cmd">normalisering</span>. Normaliseringsprocessen sikrer at data ikke bliver gentaget flere steder og data er entydig. Det man vil undgå er <span class="inl_cmd">redundans</span> og <span class="inl_cmd">inkonsistens</span>.</p>

<h2>Hvad er normalisering</h2>

<p></p>

<p>Normalisering er den proces, man gennemløber i designfasen af sin database, og den sker i tre trin:</p>

<ol class="">
	<li>Normalform 1 (NF1)</li>
	
	<ul class="disc">
		<li>Tabellen har en nøgle</li>
		<li>Der må kun være en værdi af samme type i hver post</li>
		<li>Alle poster skal være lige lange (have samme antal poster)</li>
	</ul>
	
	<li>Normalform 2 (NF2)</li>
	
	<ul class="disc">
		<li>Tabellen opfylder NF1</li>
		<li>Der må kun være en nøgle i hver tabel, der entydigt bestemmer indholdet.</li>

	</ul>
		
	<li>Normalform 3 (NF3)</li>
	
	<ul class="disc">
		<li>Tabellen opfylder NF2</li>
		<li>Hvis der er mere end et feldt der kan sættes som nøgle for andre felter skal tabellen opdeles i flere.</li>
	</ul>
</ol>

<p>Her kan du finde en (relativ) <a href="http://laerer.rhs.dk/psl/rhs/HHX-materiale/Databaser/Database%20-%20Design/Pr%C3%A6sentationer/Del%208%20-%20Normalisering.ppt" target="_blank">let gennemgang af normaliseringsprocessen</a>.</p>

<h2>Et eksempel på Nomalisering</h2>

<p>Lad os kigge på mentorskemaet ovenfor</p>

<span class="afsnit">Normalform 1 (NF1)</span>

<p>Lige nu er skemaet menneskelæseligt, men for at computeren kan arbejde med det skal vi have ændret på nogle ting.</p>

<ol class="">
	<li>Mentoren opgivet ved sit navn, men det kan ikke anvendes som nøgle, da flere mentorer kan have samme fornavn. Derfor tilføjes mentorens initialer som nøgle og navnefeltet udvides med efternavnet.</li>
	<li>Der laves 3 poster for hvert klasse mentoren er ansvarlig for</li>
</ol>

<table class="">
	<thead>
		<tr>
			<th colspan="4">Tabel 1 - Mentorer, klasser og elever</th>
		</tr>
		<tr>
			<th>Mentor (Nøgle)</th>
			<th>Navn</th>
			<th>Klasse</th>
			<th>Antal elever</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>tj</td>
			<td>Thomas Jensen</td>
			<td>1a</td>
			<td>17</td>
		</tr>
		<tr>
			<td>tj</td>
			<td>Thomas Jensen</td>
			<td>2a</td>
			<td>22</td>
		</tr>
		<tr>
			<td>tj</td>
			<td>Thomas Jensen</td>
			<td>3a</td>
			<td>21</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>Bent Andersen</td>
			<td>1b</td>
			<td>16</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>Bent Andersen</td>
			<td>2b</td>
			<td>24</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>Bent Andersen</td>
			<td>3b</td>
			<td>22</td>
		</tr>
	</tbody>
</table>

<p>Nu har vi sikret os, at der kun er en type data i hvert feldt.</p>


<span class="afsnit">Normalform 2 (NF2)</span>

<p>Hvis vi kigger på tabellen fra NF1 opdager vi at feltet <span class="inl_cmd">Mentor</span> og <span class="inl_cmd">Navn</span> begge kan ses som entydige nøgler. Da der kun må være en nøgle i NF2 må vi altså splitte tabellen i 2.</p>

<table class="">
	<thead>
		<tr>
			<th colspan="4">Tabel 1 - Mentorer, klasser og elever</th>
		</tr>
		<tr>
			<th>Mentor (Nøgle)</th>
			<th>Klasse</th>
			<th>Antal elever</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>tj</td>
			<td>1a</td>
			<td>17</td>
		</tr>
		<tr>
			<td>tj</td>
			<td>2a</td>
			<td>22</td>
		</tr>
		<tr>
			<td>tj</td>
			<td>3a</td>
			<td>21</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>1b</td>
			<td>16</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>2b</td>
			<td>24</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>3b</td>
			<td>22</td>
		</tr>
	</tbody>
</table>

<p>og</p>

<table class="">
	<thead>
		<tr>
			<th colspan="4">Tabel 2 - Mentorer</th>
		</tr>
		<tr>
			<th>Mentor (Nøgle)</th>
			<th>Navn</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>tj</td>
			<td>Thomas Jensen</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>Bent Andersen</td>
		</tr>
	</tbody>
</table>

<p>Ved at anvende NF2 har vi sikret os at den samme informationer ikke skal gentages mere end en gang ud over nøglen.</p>

<span class="afsnit">Normalform 3 (NF3)</span>

<p>Ved NF3 graver vi et spadestik dybere og søger efter sammenhænge i vores tabel som kan splittes ud i andre tabeller. Kigger vi på <span class="inl_cmd">Tabel 1</span> kan vi se at <span class="inl_cmd">Klasse</span> og <span class="inl_cmd">Antal elever</span> er afhængige af hinanden. Ved at sætte klassenavnet som nøgle for antallet af elever har vi gjort databasen mere entydig. På den måde har vi sikret os, at vi kan tilføje data </p>

<table class="">
	<thead>
		<tr>
			<th colspan="4">Tabel 1 - Mentorer og klasser</th>
		</tr>
		<tr>
			<th>Mentor (Nøgle)</th>
			<th>Klasse</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>tj</td>
			<td>1a</td>
		</tr>
		<tr>
			<td>tj</td>
			<td>2a</td>
		</tr>
		<tr>
			<td>tj</td>
			<td>3a</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>1b</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>2b</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>3b</td>
		</tr>
	</tbody>
</table>

<p>og</p>

<table class="">
	<thead>
		<tr>
			<th colspan="4">Tabel 2 - Mentorer</th>
		</tr>
		<tr>
			<th>Mentor (Nøgle)</th>
			<th>Navn</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>tj</td>
			<td>Thomas Jensen</td>
		</tr>
		<tr>
			<td>ba</td>
			<td>Bent Andersen</td>
		</tr>
	</tbody>
</table>

<p>og</p>

<table class="">
	<thead>
		<tr>
			<th colspan="4">Tabel 3 - Klasser og elever</th>
		</tr>
		<tr>
			<th>Klasse (Nøgle)</th>
			<th>Antal elever</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>1a</td>
			<td>17</td>
		</tr>
		<tr>
			<td>2a</td>
			<td>22</td>
		</tr>
		<tr>
			<td>3a</td>
			<td>21</td>
		</tr>
		<tr>
			<td>1b</td>
			<td>16</td>
		</tr>
		<tr>
			<td>2b</td>
			<td>24</td>
		</tr>
		<tr>
			<td>3b</td>
			<td>22</td>
		</tr>
	</tbody>
</table>

<h2>Opsamling</h2>

<p>Umiddelbart så ser det ud somom vi har lavet det endnu mere bøvlet end vores udgangspunkt, men metoden sikrer, at det bliver lettere at udvide og tilføje data til vores database. Ved at have opdelt databasen i 3 tabeller kan vi tilføje mobil, email og adresse til mentorerne (tabel 3 NF3)Vi vil kunne udvide tabel 3 (NF3), så den indeholder elevernes navne, mobil, email, adresse. Og når vi har tilføjet alle disse nye data kan vi nøjes med at køre normaliserings processen på de tabeller vi arbejder med uden at det vil påvirke resten af databasen.</p>

<h1>kald af data</h1>

<p></p>

<h2>Kald fra flere tabeller</h2>

<p></p>


<pre>
	<code class="SQL">
SELECT * FROM [tabel1],[tabel2]
WHERE [tabel1].[kolonne] = [*værdi*] AND [tabel2].[kolonne] = [*værdi*];
	</code>
</pre>
<p></p>


<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
	</body>

</html>
